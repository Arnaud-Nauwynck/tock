{
    "docs": [
        {
            "location": "/", 
            "text": "Bienvenue dans la documentation de Tock!\n\n\nPr\u00e9sentation\n\n\nTock\n (\nThe Open Conversation Kit\n) est une boite \u00e0 outils permettant de construire des agents conversationnels (ou bots). \n\n\nContrairement \u00e0 la plupart des autres solutions, il ne d\u00e9pend pas d\u2019API tierces (mais peut en int\u00e9grer ais\u00e9ment si n\u00e9cessaire)\u00a0: il est donc possible de conserver le contr\u00f4le complet de ses donn\u00e9es et de ses algorithmes.\n\n\nLe code source de l'ensemble se trouve sur github : \nhttps://github.com/voyages-sncf-technologies/tock\n sous la \nlicence Apache 2\n. \n\n\nDeux composants majeurs sont disponibles, le moteur NLP ( pour Natural Language Processing ou \nTALN\n en fran\u00e7ais),\n et un framework conversationnel qui int\u00e8gre les services NLP et diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack. \n\n\nLa composante NLP est ind\u00e9pendante de la partie conversationnelle. \nIl est donc possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations.\nDans certain cas d'usage importants, comme l'\nInternet des objets\n, \nl'utilisation d'un mod\u00e8le NLP seule est pertinente.\n\n\n\n\nUne plateforme pour construire des mod\u00e8les d'analyse du language naturel\n\n\nInterface d'administration\n\n\nL'outil principal est constitu\u00e9 par une interface d'administration qui permet de qualifier des \nphrases afin de construire des mod\u00e8les de traitement automatique du langage naturel ( \nTALN\n ) :\n\n\n\n\nSuivi de qualit\u00e9 des mod\u00e8les\n\n\nCette interface fournit \u00e9galement les outils pour faire \u00e9voluer les mod\u00e8les et permet de monitorer leurs pertinences :\n\n\n\n\nStanford CoreNLP\n ou \nApache OpenNLP\n\n\nLa construction automatique des mod\u00e8les est bas\u00e9e sur une de ces solutions open-sources (au choix). \nTock fournit un niveau d'indirection qui permet d'int\u00e9grer d'autres librairies NLP. \nL'int\u00e9gration de \nSparkNLP\n est d'ailleurs en cours d'\u00e9tude.\n\n\nDuckling\n\n\nUn outil de parsing de dates et de types simples bas\u00e9 sur la librairie open-source \nDuckling\n \nest \u00e9galement int\u00e9gr\u00e9 par d\u00e9faut.\n\n\nAPI NLP\n\n\nLes mod\u00e8les peuvent \u00eatre utilis\u00e9s via l'\nAPI\n mis \u00e0 disposition.\n\n\nUn framework conversationnel\n\n\nCe framework est la deuxi\u00e8me brique qui permet de construire des assistants.\n\n\nElle utilise la brique de TALN de Tock via son \nAPI\n.\n\n\nGestion du contexte et de l'historique\n\n\nLa gestion des contextes des dialogues et de l\u2019historique des conversations est automatiquement disponible. \nDes notions avanc\u00e9es comme la fusion d'entit\u00e9s sont \u00e9galement mis \u00e0 disposition.\n(par exemple le fait de pr\u00e9ciser la date \"demain\" puis plus tard \"plut\u00f4t le soir\" met automatiquement la valeur de la date \u00e0 jour)\n\n\nConnecteurs tiers\n\n\nDes connecteurs \u00e0 Facebook Messenger, Google Assistant et Slack sont disponibles. \nIl est possible d'en cr\u00e9er facilement d'autres, que ce soit pour se connecter \u00e0 d'autres canaux ou pour r\u00e9pondre \u00e0 des besoins sp\u00e9cifiques.\n\n\nSuivi des conversations\n\n\nEnfin une interface d'administration est mise \u00e0 disposition et permet de tester les bots et de suivre les conversations des utilisateurs. \n\n\nGen\u00e8se du projet\n\n\nLe projet a \u00e9t\u00e9 initi\u00e9 en 2016 par l'\u00e9quipe Innovation de \nOui.sncf\n \ndans un premier temps afin de motoriser l'analyse des commandes vocales sur ses \napplications mobiles\n.\n\n\nL'outil a ensuite \u00e9t\u00e9 utilis\u00e9 pour impl\u00e9menter son \nBot Messenger\n.\n\n\nDepuis, une \n\u00e9quipe d\u00e9di\u00e9e\n au sein de OUI.sncf fait \u00e9voluer et maintient la solution.\n\n\nL'\nassistant Google OUI.sncf\n est \u00e9galement bas\u00e9 sur Tock,\nde m\u00eame que le \nOUIbot\n.\n\n\nLes outils ont \u00e9t\u00e9 open-sourc\u00e9s dans le but de mutualiser l'effort avec d'autres \u00e9quipes\n qui souhaiterait d\u00e9velopper des assistants ou bots. \n\n\nTechnologies\n\n\nLa plateforme applicative se base sur la \nJVM\n.\n\n\nLe langage de r\u00e9f\u00e9rence est \nKotlin\n.\n\n\nLe reste de la panoplie applicative est constitu\u00e9e de \nVert.x\n et \nMongoDB\n, m\u00eame si pour l\u2019instant les applications sont essentiellement d\u00e9velopp\u00e9s en \u00ab blocking IO \u00bb. En cible, l\u2019approche \u00ab\u00a0fibers\u00a0\u00bb ( cf \nhttp://docs.paralleluniverse.co/quasar/\n) sera privil\u00e9gi\u00e9e.\n\n\nLes interfaces d'administration sont impl\u00e9ment\u00e9es en \nAngular4\n/\nTypescript\n.\n\n\nCependant il est tout \u00e0 fait possible de d\u00e9velopper des applications en utilisant d'autres languages de programmation via les APIs mis \u00e0 disposition.\n\n\nLes diff\u00e9rents projets open-sourc\u00e9s\n\n\n\n\n\n\nLe projet principal se trouve sous licence \nApache\n. Le code source est disponible sur GitHub : \nhttps://github.com/voyages-sncf-technologies/tock\n\n\n\n\n\n\nCependant une d\u00e9pendance optionnelle,  \nStanford CoreNLP\n, est sous licence \nGPL\n. \n Le code utilisant cette d\u00e9pendance se trouve donc dans un projet \u00e0 part, sous licence GPL : \nhttps://github.com/voyages-sncf-technologies/tock-corenlp\n\n\n\n\n\n\nEnfin deux autres projets sont mis \u00e0 disposition : \n\n\n\n\nUn projet contenant des images dockers avec comme objectif de faciliter la prise en main : \nhttps://github.com/voyages-sncf-technologies/tock-docker\n\n\nUn projet contenant un exemple d'impl\u00e9mentation de bot se basant sur les \nAPI SNCF\n en Open Data : \nhttps://github.com/voyages-sncf-technologies/tock-bot-open-data", 
            "title": "Pr\u00e9sentation"
        }, 
        {
            "location": "/#bienvenue-dans-la-documentation-de-tock", 
            "text": "", 
            "title": "Bienvenue dans la documentation de Tock!"
        }, 
        {
            "location": "/#presentation", 
            "text": "Tock  ( The Open Conversation Kit ) est une boite \u00e0 outils permettant de construire des agents conversationnels (ou bots).   Contrairement \u00e0 la plupart des autres solutions, il ne d\u00e9pend pas d\u2019API tierces (mais peut en int\u00e9grer ais\u00e9ment si n\u00e9cessaire)\u00a0: il est donc possible de conserver le contr\u00f4le complet de ses donn\u00e9es et de ses algorithmes.  Le code source de l'ensemble se trouve sur github :  https://github.com/voyages-sncf-technologies/tock  sous la  licence Apache 2 .   Deux composants majeurs sont disponibles, le moteur NLP ( pour Natural Language Processing ou  TALN  en fran\u00e7ais),\n et un framework conversationnel qui int\u00e8gre les services NLP et diff\u00e9rents connecteurs comme Messenger, Google Assistant ou Slack.   La composante NLP est ind\u00e9pendante de la partie conversationnelle. \nIl est donc possible d'utiliser le NLP sans devoir ma\u00eetriser la complexit\u00e9 induite par la gestion des conversations.\nDans certain cas d'usage importants, comme l' Internet des objets , \nl'utilisation d'un mod\u00e8le NLP seule est pertinente.", 
            "title": "Pr\u00e9sentation"
        }, 
        {
            "location": "/#une-plateforme-pour-construire-des-modeles-danalyse-du-language-naturel", 
            "text": "", 
            "title": "Une plateforme pour construire des mod\u00e8les d'analyse du language naturel"
        }, 
        {
            "location": "/#interface-dadministration", 
            "text": "L'outil principal est constitu\u00e9 par une interface d'administration qui permet de qualifier des \nphrases afin de construire des mod\u00e8les de traitement automatique du langage naturel (  TALN  ) :", 
            "title": "Interface d'administration"
        }, 
        {
            "location": "/#suivi-de-qualite-des-modeles", 
            "text": "Cette interface fournit \u00e9galement les outils pour faire \u00e9voluer les mod\u00e8les et permet de monitorer leurs pertinences :", 
            "title": "Suivi de qualit\u00e9 des mod\u00e8les"
        }, 
        {
            "location": "/#stanford-corenlp-ou-apache-opennlp", 
            "text": "La construction automatique des mod\u00e8les est bas\u00e9e sur une de ces solutions open-sources (au choix). \nTock fournit un niveau d'indirection qui permet d'int\u00e9grer d'autres librairies NLP. \nL'int\u00e9gration de  SparkNLP  est d'ailleurs en cours d'\u00e9tude.", 
            "title": "Stanford CoreNLP ou Apache OpenNLP"
        }, 
        {
            "location": "/#duckling", 
            "text": "Un outil de parsing de dates et de types simples bas\u00e9 sur la librairie open-source  Duckling  \nest \u00e9galement int\u00e9gr\u00e9 par d\u00e9faut.", 
            "title": "Duckling"
        }, 
        {
            "location": "/#api-nlp", 
            "text": "Les mod\u00e8les peuvent \u00eatre utilis\u00e9s via l' API  mis \u00e0 disposition.", 
            "title": "API NLP"
        }, 
        {
            "location": "/#un-framework-conversationnel", 
            "text": "Ce framework est la deuxi\u00e8me brique qui permet de construire des assistants.  Elle utilise la brique de TALN de Tock via son  API .", 
            "title": "Un framework conversationnel"
        }, 
        {
            "location": "/#gestion-du-contexte-et-de-lhistorique", 
            "text": "La gestion des contextes des dialogues et de l\u2019historique des conversations est automatiquement disponible. \nDes notions avanc\u00e9es comme la fusion d'entit\u00e9s sont \u00e9galement mis \u00e0 disposition.\n(par exemple le fait de pr\u00e9ciser la date \"demain\" puis plus tard \"plut\u00f4t le soir\" met automatiquement la valeur de la date \u00e0 jour)", 
            "title": "Gestion du contexte et de l'historique"
        }, 
        {
            "location": "/#connecteurs-tiers", 
            "text": "Des connecteurs \u00e0 Facebook Messenger, Google Assistant et Slack sont disponibles. \nIl est possible d'en cr\u00e9er facilement d'autres, que ce soit pour se connecter \u00e0 d'autres canaux ou pour r\u00e9pondre \u00e0 des besoins sp\u00e9cifiques.", 
            "title": "Connecteurs tiers"
        }, 
        {
            "location": "/#suivi-des-conversations", 
            "text": "Enfin une interface d'administration est mise \u00e0 disposition et permet de tester les bots et de suivre les conversations des utilisateurs.", 
            "title": "Suivi des conversations"
        }, 
        {
            "location": "/#genese-du-projet", 
            "text": "Le projet a \u00e9t\u00e9 initi\u00e9 en 2016 par l'\u00e9quipe Innovation de  Oui.sncf  \ndans un premier temps afin de motoriser l'analyse des commandes vocales sur ses  applications mobiles .  L'outil a ensuite \u00e9t\u00e9 utilis\u00e9 pour impl\u00e9menter son  Bot Messenger .  Depuis, une  \u00e9quipe d\u00e9di\u00e9e  au sein de OUI.sncf fait \u00e9voluer et maintient la solution.  L' assistant Google OUI.sncf  est \u00e9galement bas\u00e9 sur Tock,\nde m\u00eame que le  OUIbot .  Les outils ont \u00e9t\u00e9 open-sourc\u00e9s dans le but de mutualiser l'effort avec d'autres \u00e9quipes\n qui souhaiterait d\u00e9velopper des assistants ou bots.", 
            "title": "Gen\u00e8se du projet"
        }, 
        {
            "location": "/#technologies", 
            "text": "La plateforme applicative se base sur la  JVM .  Le langage de r\u00e9f\u00e9rence est  Kotlin .  Le reste de la panoplie applicative est constitu\u00e9e de  Vert.x  et  MongoDB , m\u00eame si pour l\u2019instant les applications sont essentiellement d\u00e9velopp\u00e9s en \u00ab blocking IO \u00bb. En cible, l\u2019approche \u00ab\u00a0fibers\u00a0\u00bb ( cf  http://docs.paralleluniverse.co/quasar/ ) sera privil\u00e9gi\u00e9e.  Les interfaces d'administration sont impl\u00e9ment\u00e9es en  Angular4 / Typescript .  Cependant il est tout \u00e0 fait possible de d\u00e9velopper des applications en utilisant d'autres languages de programmation via les APIs mis \u00e0 disposition.", 
            "title": "Technologies"
        }, 
        {
            "location": "/#les-differents-projets-open-sources", 
            "text": "Le projet principal se trouve sous licence  Apache . Le code source est disponible sur GitHub :  https://github.com/voyages-sncf-technologies/tock    Cependant une d\u00e9pendance optionnelle,   Stanford CoreNLP , est sous licence  GPL . \n Le code utilisant cette d\u00e9pendance se trouve donc dans un projet \u00e0 part, sous licence GPL :  https://github.com/voyages-sncf-technologies/tock-corenlp    Enfin deux autres projets sont mis \u00e0 disposition :    Un projet contenant des images dockers avec comme objectif de faciliter la prise en main :  https://github.com/voyages-sncf-technologies/tock-docker  Un projet contenant un exemple d'impl\u00e9mentation de bot se basant sur les  API SNCF  en Open Data :  https://github.com/voyages-sncf-technologies/tock-bot-open-data", 
            "title": "Les diff\u00e9rents projets open-sourc\u00e9s"
        }, 
        {
            "location": "/pour-commencer/", 
            "text": "Commencer \u00e0 utiliser Tock\n\n\nUn exemple de bot\n\n\nUn bot d'exemple utilisant Tock est mis \u00e0 disposition\u00a0sur github : \nhttps://github.com/voyages-sncf-technologies/tock-bot-open-data\n.\n\n\nIl se base sur les \nAPI Open Data de la SNCF\n, et pr\u00e9sente des fonctionnalit\u00e9s minimales permettant de d\u00e9montrer l\u2019usage de Tock. \n\n\nIl s'agit d'un bon point de d\u00e9part, puisque il comporte \u00e9galement un mod\u00e8le NLP tr\u00e8s simple.\nBien entendu, comme le mod\u00e8le n'est pas complet, la qualit\u00e9 du bot est faible, mais suffit cependant \u00e0 d\u00e9montrer le principe de l'outil.\n\n\nDans la suite de la documentation, nous nous r\u00e9f\u00e9rerons \u00e0 cet exemple pour couvrir l'ensemble des fonctionnalit\u00e9s. \n\n\nImages Docker\n\n\nDes images docker sont mises \u00e0 disposition pour faciliter le d\u00e9marrage.\n\n\nCes images sont disponibles dans le \nHub Docker\n.\n\n\nLe code source utilis\u00e9 pour construire ces images, ainsi que les fichiers \ndocker-compose\n \nutilis\u00e9s pour d\u00e9marrer l'ensemble de la boite \u00e0 outils \nTock\n sont disponibles dans le repository github \nhttps://github.com/voyages-sncf-technologies/tock-docker\n.\n\n\nD\u00e9marrer l'interface d'administration\n\n\n    \n#get the last docker-compose file\n\n    curl -o docker-compose.yml https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/docker-compose.yml\n    \n#get the last tag\n\n    curl -o .env https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/.env\n    \n#launch the stack\n\n    docker-compose up\n\n\n\n\n\nL'interface d'administration NLP est maintenant disponible sur le port 80 : \nhttp://localhost\n\n\nl'identifiant par d\u00e9faut est \nadmin@app.com\n et le mot de passe \npassword\n.\n\n\nBot d'exemple bas\u00e9 sur les API Open Data\n\n\nUne image docker est mis \u00e0 disposition pour le lancer directement.\nLes instructions pour la d\u00e9marrer sont pr\u00e9cis\u00e9es dans le \nprojet github contenant les images docker\n.\n\n\nMenu de l'interface d'administration\n\n\nLe menu \u00e0 gauche permet d'acc\u00e9der aux diff\u00e9rentes fonctionnalit\u00e9s.\n\n\nLe menu \nConfiguration\n permet de cr\u00e9er de nouveaux mod\u00e8le et de param\u00e9trer les options importantes.\n\n\nLes menus \nNLP\n et \nNLP QA\n sont d\u00e9di\u00e9s \u00e0 la construction de mod\u00e8les.\n\n\nLes menus \nBuild\n, \nTest\n et \nMonitoring\n sont eux utilis\u00e9s dans le cadre de la construction de bots ou d'assistants.", 
            "title": "Pour commencer"
        }, 
        {
            "location": "/pour-commencer/#commencer-a-utiliser-tock", 
            "text": "", 
            "title": "Commencer \u00e0 utiliser Tock"
        }, 
        {
            "location": "/pour-commencer/#un-exemple-de-bot", 
            "text": "Un bot d'exemple utilisant Tock est mis \u00e0 disposition\u00a0sur github :  https://github.com/voyages-sncf-technologies/tock-bot-open-data .  Il se base sur les  API Open Data de la SNCF , et pr\u00e9sente des fonctionnalit\u00e9s minimales permettant de d\u00e9montrer l\u2019usage de Tock.   Il s'agit d'un bon point de d\u00e9part, puisque il comporte \u00e9galement un mod\u00e8le NLP tr\u00e8s simple.\nBien entendu, comme le mod\u00e8le n'est pas complet, la qualit\u00e9 du bot est faible, mais suffit cependant \u00e0 d\u00e9montrer le principe de l'outil.  Dans la suite de la documentation, nous nous r\u00e9f\u00e9rerons \u00e0 cet exemple pour couvrir l'ensemble des fonctionnalit\u00e9s.", 
            "title": "Un exemple de bot"
        }, 
        {
            "location": "/pour-commencer/#images-docker", 
            "text": "Des images docker sont mises \u00e0 disposition pour faciliter le d\u00e9marrage.  Ces images sont disponibles dans le  Hub Docker .  Le code source utilis\u00e9 pour construire ces images, ainsi que les fichiers  docker-compose  \nutilis\u00e9s pour d\u00e9marrer l'ensemble de la boite \u00e0 outils  Tock  sont disponibles dans le repository github  https://github.com/voyages-sncf-technologies/tock-docker .", 
            "title": "Images Docker"
        }, 
        {
            "location": "/pour-commencer/#demarrer-linterface-dadministration", 
            "text": "#get the last docker-compose file \n    curl -o docker-compose.yml https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/docker-compose.yml\n     #get the last tag \n    curl -o .env https://raw.githubusercontent.com/voyages-sncf-technologies/tock-docker/master/.env\n     #launch the stack \n    docker-compose up  L'interface d'administration NLP est maintenant disponible sur le port 80 :  http://localhost  l'identifiant par d\u00e9faut est  admin@app.com  et le mot de passe  password .", 
            "title": "D\u00e9marrer l'interface d'administration"
        }, 
        {
            "location": "/pour-commencer/#bot-dexemple-base-sur-les-api-open-data", 
            "text": "Une image docker est mis \u00e0 disposition pour le lancer directement.\nLes instructions pour la d\u00e9marrer sont pr\u00e9cis\u00e9es dans le  projet github contenant les images docker .", 
            "title": "Bot d'exemple bas\u00e9 sur les API Open Data"
        }, 
        {
            "location": "/pour-commencer/#menu-de-linterface-dadministration", 
            "text": "Le menu \u00e0 gauche permet d'acc\u00e9der aux diff\u00e9rentes fonctionnalit\u00e9s.  Le menu  Configuration  permet de cr\u00e9er de nouveaux mod\u00e8le et de param\u00e9trer les options importantes.  Les menus  NLP  et  NLP QA  sont d\u00e9di\u00e9s \u00e0 la construction de mod\u00e8les.  Les menus  Build ,  Test  et  Monitoring  sont eux utilis\u00e9s dans le cadre de la construction de bots ou d'assistants.", 
            "title": "Menu de l'interface d'administration"
        }, 
        {
            "location": "/construire-le-modele/", 
            "text": "Mise en place d'un mod\u00e8le NLP\n\n\nVue d'ensemble\n\n\nSept onglets sont disponibles :\n\n\n\n\nTry it\n : permet d'ajouter ou de tester l'analyse de nouvelles phrases\n\n\nInbox\n : l'ensemble des phrases non encore qualifi\u00e9es\n\n\nArchive\n : l'ensembles des phrases archiv\u00e9es, c'est \u00e0 dire volontairement non encore reconnue par le mod\u00e8le\n\n\nSearch\n : une interface de recherche avanc\u00e9e qui permet de rechercher les phrases enregistr\u00e9es, qu'elles soient ou non qualifi\u00e9es  \n\n\nIntents\n : la liste des intentions du mod\u00e8le\n\n\nEntities\n : la liste des entit\u00e9s du mod\u00e8le\n\n\nLogs\n : La liste des requ\u00eates interrogeant le mod\u00e8le \n\n\n\n\nL'utilisateur est redirig\u00e9 par d\u00e9faut sur la cat\u00e9gorie \nInbox\n.\n\n\n\n\nAjouter et qualifier des phrases\n\n\nPour ajouter une phrase\n\n\nCliquez sur le menu \nTry It\n puis indiquez votre phrase.\nIl faut lui attribuer une intention en s\u00e9lectionnant \"Create a New Intent\" dans le liste de s\u00e9lection \"Intent\".\n\n\n\n\nSp\u00e9cifier des entit\u00e9s\n\n\nSi n\u00e9cessaire, vous pouvez ensuite sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse pour cette intention,\nen s\u00e9lectionnant les portions de phrases correspondantes \u00e0 ces entit\u00e9s, puis en cliquant sur le bouton \"Add New Entity\" qui vient d'appara\u00eetre\n\n\n\n\nA vous de choisir ensuite un type d'entit\u00e9 existant, ou d'en cr\u00e9er un nouveau, puis de donner un role \u00e0 cette entit\u00e9.\n\n\n\n\nTypes d'entit\u00e9s pr\u00e9d\u00e9finies\n\n\nDans cette fen\u00eatre de cr\u00e9ation d'entit\u00e9s, vous pouvez constater qu'il existe d\u00e9j\u00e0 un certain nombre d'entit\u00e9s (pr\u00e9fix\u00e9es par \nduckling:\n).\nIl s'agit d'entit\u00e9s reconnues par la librairie \u00e9ponyme. Elle seront automatiquement reconnues et valoris\u00e9es pour cette intention si vous les\nsp\u00e9cifiez dans au moins une phrase de cette intention.\n\n\nSp\u00e9cifier plusieurs entit\u00e9s\n\n\nIl est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.\n\n\n\n\nValider la phrase\n\n\nTerminez la qualification de la phrase en cliquant sur le bouton \"Validate\". \nAu bout de 2 phrases qualifi\u00e9es pour une intention donn\u00e9e, il est possible que le 3\u00e8me phrase ajout\u00e9e soit imm\u00e9diatement\nreconnue.\n\n\n\n\nSi elle est qualifi\u00e9e correctement, vous n'avez plus qu'\u00e0 cliquer sur \"Validate\" pour confirmer que la phrase est correcte.\nSi ce n'est pas le cas, \u00e0 vous d'en corriger le sens avant de la valider.\n\n\nVous \u00eates en train de construire votre premier mod\u00e8le !\n\n\nRecherche de phrases\n\n\nL'onglet de recherche\n\n\nL'onglet \nSearch\n permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res.\nLe plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res.\n\n\n\n\nCela permet de consulter les phrases faisant partie de votre mod\u00e8le,\net vous donne la possibilit\u00e9 de faire \u00e9voluer les qualifications de ces phrases au cours du temps.\n\n\nLes diff\u00e9rents \u00e9tats d'une phrase\n\n\nChaque phrase \u00e0 un \u00e9tat (\"Status\") qui peut \u00e9voluer au cours du temps.\n\n\n\n\nInbox\n : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le\n\n\nValidated\n : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante)\n\n\nIncluded in model\n : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP\n\n\n\n\nCaract\u00e9ristiques avanc\u00e9es\n\n\nEn cliquant sur le menu \"Applications\", vous acc\u00e9dez \u00e0 la liste des applications disponibles.\n\n\n\n\nEn cliquant sur le bouton de modification, plusieurs options sont disponibles.\n\n\nS\u00e9lection du moteur NLP\n\n\nVous avez la possibilit\u00e9 de s\u00e9lectionner la librairie NLP utilis\u00e9e par cette application \u00e0 l'aide du bouton radio \"NLP engine\".\n\n\nUtilisation des mod\u00e8les d'entit\u00e9s\n\n\n\n\nCette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. \nPar exemple, si vous cr\u00e9ez une intention avec une entit\u00e9 \nduckling:datetime\n, les dates seront automatiquement\nreconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention \n(En interne un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le).\n\n\nCette option est activ\u00e9e par d\u00e9faut, il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels\nla d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s. \n\n\nUtiliser les sous-entit\u00e9s\n\n\nSi vous activez cette option, vous allez \u00eatre en mesure de qualifier plusieurs niveaux d'entit\u00e9s :\n\n\n\n\nLe nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.", 
            "title": "Construire le mod\u00e8le"
        }, 
        {
            "location": "/construire-le-modele/#mise-en-place-dun-modele-nlp", 
            "text": "", 
            "title": "Mise en place d'un mod\u00e8le NLP"
        }, 
        {
            "location": "/construire-le-modele/#vue-densemble", 
            "text": "Sept onglets sont disponibles :   Try it  : permet d'ajouter ou de tester l'analyse de nouvelles phrases  Inbox  : l'ensemble des phrases non encore qualifi\u00e9es  Archive  : l'ensembles des phrases archiv\u00e9es, c'est \u00e0 dire volontairement non encore reconnue par le mod\u00e8le  Search  : une interface de recherche avanc\u00e9e qui permet de rechercher les phrases enregistr\u00e9es, qu'elles soient ou non qualifi\u00e9es    Intents  : la liste des intentions du mod\u00e8le  Entities  : la liste des entit\u00e9s du mod\u00e8le  Logs  : La liste des requ\u00eates interrogeant le mod\u00e8le    L'utilisateur est redirig\u00e9 par d\u00e9faut sur la cat\u00e9gorie  Inbox .", 
            "title": "Vue d'ensemble"
        }, 
        {
            "location": "/construire-le-modele/#ajouter-et-qualifier-des-phrases", 
            "text": "", 
            "title": "Ajouter et qualifier des phrases"
        }, 
        {
            "location": "/construire-le-modele/#pour-ajouter-une-phrase", 
            "text": "Cliquez sur le menu  Try It  puis indiquez votre phrase.\nIl faut lui attribuer une intention en s\u00e9lectionnant \"Create a New Intent\" dans le liste de s\u00e9lection \"Intent\".", 
            "title": "Pour ajouter une phrase"
        }, 
        {
            "location": "/construire-le-modele/#specifier-des-entites", 
            "text": "Si n\u00e9cessaire, vous pouvez ensuite sp\u00e9cifier les entit\u00e9s que vous souhaitez que votre mod\u00e8le reconnaisse pour cette intention,\nen s\u00e9lectionnant les portions de phrases correspondantes \u00e0 ces entit\u00e9s, puis en cliquant sur le bouton \"Add New Entity\" qui vient d'appara\u00eetre   A vous de choisir ensuite un type d'entit\u00e9 existant, ou d'en cr\u00e9er un nouveau, puis de donner un role \u00e0 cette entit\u00e9.", 
            "title": "Sp\u00e9cifier des entit\u00e9s"
        }, 
        {
            "location": "/construire-le-modele/#types-dentites-predefinies", 
            "text": "Dans cette fen\u00eatre de cr\u00e9ation d'entit\u00e9s, vous pouvez constater qu'il existe d\u00e9j\u00e0 un certain nombre d'entit\u00e9s (pr\u00e9fix\u00e9es par  duckling: ).\nIl s'agit d'entit\u00e9s reconnues par la librairie \u00e9ponyme. Elle seront automatiquement reconnues et valoris\u00e9es pour cette intention si vous les\nsp\u00e9cifiez dans au moins une phrase de cette intention.", 
            "title": "Types d'entit\u00e9s pr\u00e9d\u00e9finies"
        }, 
        {
            "location": "/construire-le-modele/#specifier-plusieurs-entites", 
            "text": "Il est bien s\u00fbr possible d'avoir plusieurs occurrences du m\u00eame role, ou d'un r\u00f4le diff\u00e9rent dans la m\u00eame phrase.", 
            "title": "Sp\u00e9cifier plusieurs entit\u00e9s"
        }, 
        {
            "location": "/construire-le-modele/#valider-la-phrase", 
            "text": "Terminez la qualification de la phrase en cliquant sur le bouton \"Validate\". \nAu bout de 2 phrases qualifi\u00e9es pour une intention donn\u00e9e, il est possible que le 3\u00e8me phrase ajout\u00e9e soit imm\u00e9diatement\nreconnue.   Si elle est qualifi\u00e9e correctement, vous n'avez plus qu'\u00e0 cliquer sur \"Validate\" pour confirmer que la phrase est correcte.\nSi ce n'est pas le cas, \u00e0 vous d'en corriger le sens avant de la valider.  Vous \u00eates en train de construire votre premier mod\u00e8le !", 
            "title": "Valider la phrase"
        }, 
        {
            "location": "/construire-le-modele/#recherche-de-phrases", 
            "text": "", 
            "title": "Recherche de phrases"
        }, 
        {
            "location": "/construire-le-modele/#longlet-de-recherche", 
            "text": "L'onglet  Search  permet de parcourir l'ensemble des phrases du mod\u00e8le en utilisant un certain nombre de crit\u00e8res.\nLe plus utilis\u00e9 est la recherche texte simple pour lequel il est \u00e9galement possible d'utiliser des expressions r\u00e9guli\u00e8res.   Cela permet de consulter les phrases faisant partie de votre mod\u00e8le,\net vous donne la possibilit\u00e9 de faire \u00e9voluer les qualifications de ces phrases au cours du temps.", 
            "title": "L'onglet de recherche"
        }, 
        {
            "location": "/construire-le-modele/#les-differents-etats-dune-phrase", 
            "text": "Chaque phrase \u00e0 un \u00e9tat (\"Status\") qui peut \u00e9voluer au cours du temps.   Inbox  : La phrase n'a pas encore \u00e9t\u00e9 qualifi\u00e9e et ne fait pas partie du mod\u00e8le  Validated  : La phrase a \u00e9t\u00e9 valid\u00e9e mais n'est pas encore pris en compte dans les mod\u00e8les de NLP (cela peut prendre du temps dans le cas de mod\u00e8les de taille importante)  Included in model  : La phrase a \u00e9t\u00e9 valid\u00e9e et a \u00e9t\u00e9 prise en compte dans les mod\u00e8les de NLP", 
            "title": "Les diff\u00e9rents \u00e9tats d'une phrase"
        }, 
        {
            "location": "/construire-le-modele/#caracteristiques-avancees", 
            "text": "En cliquant sur le menu \"Applications\", vous acc\u00e9dez \u00e0 la liste des applications disponibles.   En cliquant sur le bouton de modification, plusieurs options sont disponibles.", 
            "title": "Caract\u00e9ristiques avanc\u00e9es"
        }, 
        {
            "location": "/construire-le-modele/#selection-du-moteur-nlp", 
            "text": "Vous avez la possibilit\u00e9 de s\u00e9lectionner la librairie NLP utilis\u00e9e par cette application \u00e0 l'aide du bouton radio \"NLP engine\".", 
            "title": "S\u00e9lection du moteur NLP"
        }, 
        {
            "location": "/construire-le-modele/#utilisation-des-modeles-dentites", 
            "text": "Cette option permet de r\u00e9utiliser des mod\u00e8les d'entit\u00e9s pr\u00e9-construits dans vos nouvelles intentions. \nPar exemple, si vous cr\u00e9ez une intention avec une entit\u00e9  duckling:datetime , les dates seront automatiquement\nreconnues pour cette intention dans tous les nouvelles phrases attribu\u00e9es \u00e0 cette intention \n(En interne un arbitrage est effectu\u00e9 entre les informations provenant des mod\u00e8les d'entit\u00e9s pr\u00e9-construits et les informations tir\u00e9es de votre propre mod\u00e8le).  Cette option est activ\u00e9e par d\u00e9faut, il peut \u00eatre utile de la d\u00e9sactiver pour les mod\u00e8les de taille tr\u00e8s importante, pour lesquels\nla d\u00e9tection native sera sup\u00e9rieure dans quasiment tous les cas \u00e0 celle des mod\u00e8les d'entit\u00e9s.", 
            "title": "Utilisation des mod\u00e8les d'entit\u00e9s"
        }, 
        {
            "location": "/construire-le-modele/#utiliser-les-sous-entites", 
            "text": "Si vous activez cette option, vous allez \u00eatre en mesure de qualifier plusieurs niveaux d'entit\u00e9s :   Le nombre de niveaux n'est pas limit\u00e9, mais il est conseill\u00e9 de ne pas en sp\u00e9cifier plus de 3 ou 4.", 
            "title": "Utiliser les sous-entit\u00e9s"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/", 
            "text": "Evaluer la pertinence du mod\u00e8le NLP\n\n\nDonn\u00e9es disponibles\n\n\nCinq onglets permettent de contr\u00f4ler la pertinence du mod\u00e8le :\n\n\n\n\nStats\n : statistiques minimales qui permettent de suivre la qualit\u00e9 du mod\u00e8le en production. Elles comprennent:\n\n\nl'auto-\u00e9valuation du mod\u00e8le sur sa pertinence en terme de reconnaissance d'intention et d'entit\u00e9s\n\n\nle nombre d'appels et le nombre d'erreurs\n\n\nle temps moyen d'ex\u00e9cution \n\n\n\n\n\n\nTest Trend\n : \u00e9volution de la pertinence des \ntests partiels de mod\u00e8le\n \n\n\nIntent Errors\n : la liste des erreurs d'intention (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le\n\n\nEntity Errors\n : la liste des erreurs d'entit\u00e9 (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le\n\n\nModel Builds\n : la liste des constructions des mod\u00e8les avec notamment le type de mod\u00e8le, le nombre de phrases et la dur\u00e9e de construction\n\n\n\n\nTests partiels de mod\u00e8le\n\n\nLes tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification,\nou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles.\n\n\nIl s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire\nun mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le.\n\n\nUne fois le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois\npour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel.\n\n\nCes tests partiels ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents.\n\n\nLancement des tests\n\n\nPar d\u00e9faut les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes.\nIl est possible de configurer ce comportement avec la propri\u00e9t\u00e9 \ntock_test_model_timeframe\n (=0,5 par d\u00e9faut)\n\n\nIntentions en erreur\n\n\nC'est l'objet de l'onglet \nIntent Errors\n. Voici par exemple une copie d'\u00e9cran pour le mod\u00e8le bot open-data.\n\n\n\n\nComme il s'agit d'un mod\u00e8le d'exemple, aucune \nvraie\n erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. \nOn peut tout de m\u00eame constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement avec une probabilit\u00e9 \u00e9lev\u00e9e.\n\n\nPour chaque phrase il est possible via la colonne \nActions\n de confirmer que le mod\u00e8le de base est correct (\nValidate Intent\n) \nou de corriger l'\u00e9ventuelle erreur d\u00e9tect\u00e9e (\nChange The Intent\n). \n\n\nEntit\u00e9s en erreur\n\n\nElles sont consultables de mani\u00e8re sym\u00e9trique via l'onglet \nEntity Errors\n.", 
            "title": "Evaluer la pertinence du mod\u00e8le"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/#evaluer-la-pertinence-du-modele-nlp", 
            "text": "", 
            "title": "Evaluer la pertinence du mod\u00e8le NLP"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/#donnees-disponibles", 
            "text": "Cinq onglets permettent de contr\u00f4ler la pertinence du mod\u00e8le :   Stats  : statistiques minimales qui permettent de suivre la qualit\u00e9 du mod\u00e8le en production. Elles comprennent:  l'auto-\u00e9valuation du mod\u00e8le sur sa pertinence en terme de reconnaissance d'intention et d'entit\u00e9s  le nombre d'appels et le nombre d'erreurs  le temps moyen d'ex\u00e9cution     Test Trend  : \u00e9volution de la pertinence des  tests partiels de mod\u00e8le    Intent Errors  : la liste des erreurs d'intention (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le  Entity Errors  : la liste des erreurs d'entit\u00e9 (vraies ou fausses) trouv\u00e9es lors des tests partiels de mod\u00e8le  Model Builds  : la liste des constructions des mod\u00e8les avec notamment le type de mod\u00e8le, le nombre de phrases et la dur\u00e9e de construction", 
            "title": "Donn\u00e9es disponibles"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/#tests-partiels-de-modele", 
            "text": "Les tests partiels de mod\u00e8le constituent un moyen classique de d\u00e9tecter les erreurs de qualification,\nou les probl\u00e8mes de proximit\u00e9 des intentions (ou entit\u00e9s) entre elles.  Il s'agit de prendre une partie du mod\u00e8le actuelle au hasard (par exemple 90% des phrases du mod\u00e8le) afin de construire\nun mod\u00e8le l\u00e9g\u00e8rement moins pertinent, puis de tester les 10% restant avec ce nouveau mod\u00e8le.  Une fois le principe pos\u00e9, il ne reste plus qu'\u00e0 r\u00e9p\u00e9ter le processus un certain nombre de fois\npour que les erreurs les plus fr\u00e9quentes soient pr\u00e9sent\u00e9es \u00e0 un correcteur manuel.  Ces tests partiels ne pr\u00e9sentent une utilit\u00e9 qu'avec des mod\u00e8les d\u00e9j\u00e0 cons\u00e9quents.", 
            "title": "Tests partiels de mod\u00e8le"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/#lancement-des-tests", 
            "text": "Par d\u00e9faut les tests sont programm\u00e9s pour \u00eatre lanc\u00e9s de minuit \u00e0 5h du matin, toutes les 10 minutes.\nIl est possible de configurer ce comportement avec la propri\u00e9t\u00e9  tock_test_model_timeframe  (=0,5 par d\u00e9faut)", 
            "title": "Lancement des tests"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/#intentions-en-erreur", 
            "text": "C'est l'objet de l'onglet  Intent Errors . Voici par exemple une copie d'\u00e9cran pour le mod\u00e8le bot open-data.   Comme il s'agit d'un mod\u00e8le d'exemple, aucune  vraie  erreur n'a \u00e9t\u00e9 d\u00e9tect\u00e9e. \nOn peut tout de m\u00eame constater que dans certains cas le mod\u00e8le se trompe syst\u00e9matiquement avec une probabilit\u00e9 \u00e9lev\u00e9e.  Pour chaque phrase il est possible via la colonne  Actions  de confirmer que le mod\u00e8le de base est correct ( Validate Intent ) \nou de corriger l'\u00e9ventuelle erreur d\u00e9tect\u00e9e ( Change The Intent ).", 
            "title": "Intentions en erreur"
        }, 
        {
            "location": "/evaluer-la-pertinence-du-modele/#entites-en-erreur", 
            "text": "Elles sont consultables de mani\u00e8re sym\u00e9trique via l'onglet  Entity Errors .", 
            "title": "Entit\u00e9s en erreur"
        }, 
        {
            "location": "/api-nlp/", 
            "text": "Une API permettant d'analyser une nouvelle phrase \u00e0 partir d'un mod\u00e8le est disponible.\n\n\nVeuillez consulter sa documentation \nici\n.\n\n\nSi vous souhaitez la tester en condition r\u00e9elle, elle est consultable \u00e0 partir des \nimages docker\n\n\u00e0 l'adresse \nhttp://localhost/doc/index.html", 
            "title": "L'api NLP"
        }, 
        {
            "location": "/presentation-du-bot-open-data/", 
            "text": "Introduction \u00e0 la boite \u00e0 outils conversationnelle\n\n\nPartir d'un exemple\n\n\nUn bon point de d\u00e9part est le code source du \nbot Open Data\n \n\n\nSuivez les instructions pr\u00e9sentes dans le README du projet pour d\u00e9marrer le bot dans l'IDE (ne configurez pas Messenger ou Google Assistant \u00e0 ce stade),\npuis connectez vous \u00e0 l'interface d'administration. Le bot est d'ors et d\u00e9j\u00e0 testable.\n\n\nL'onglet Test\n\n\nVia cet onglet, vous pouvez commencer \u00e0 tester le bot :\n\n\n\n\nL'interface est minimale car il s'agit d'un mode de test. \n\n\nL'objectif reste de faire dialoguer vos utilisateurs avec le bot via des canaux comme Messenger, Google Assistant...\nou vos sites ou applications.\n\n\nL'onglet Monitoring\n\n\nIl est ensuite possible de consulter la discussion que vous venez d'avoir avec le bot via l'onglet Monitoring\n\n\n\n\nIci, le canal est indiqu\u00e9 comme \u00e9tant celui de Messenger puisque il a \u00e9t\u00e9 simul\u00e9 une conversation Messenger.\n\n\nL'onglet Build\n\n\nAjouter une intention avec r\u00e9ponse sp\u00e9cifique\n\n\nVia la cat\u00e9gorie \nAdd new Answer\n, il est possible d'ajouter du comportement sp\u00e9cifique :\n\n\n\n\nPuis de tester ensuite la nouvelle intention et sa r\u00e9ponse :\n\n\n\n\nModification des r\u00e9ponses et internationalisation\n\n\nEnfin il est possible de modifier chaque r\u00e9ponse du bot par type d'interface (chat/voix), par type de connecteur et par langue\nvia l'onglet \ni18n\n.\n\n\nIl est aussi possible de rajouter des r\u00e9ponses alternatives ( \u00e0 chaque fois une r\u00e9ponse de la liste sera choisie au hasard) via cette interface.", 
            "title": "Pr\u00e9sentation du bot Open Data"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#introduction-a-la-boite-a-outils-conversationnelle", 
            "text": "", 
            "title": "Introduction \u00e0 la boite \u00e0 outils conversationnelle"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#partir-dun-exemple", 
            "text": "Un bon point de d\u00e9part est le code source du  bot Open Data    Suivez les instructions pr\u00e9sentes dans le README du projet pour d\u00e9marrer le bot dans l'IDE (ne configurez pas Messenger ou Google Assistant \u00e0 ce stade),\npuis connectez vous \u00e0 l'interface d'administration. Le bot est d'ors et d\u00e9j\u00e0 testable.", 
            "title": "Partir d'un exemple"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#longlet-test", 
            "text": "Via cet onglet, vous pouvez commencer \u00e0 tester le bot :   L'interface est minimale car il s'agit d'un mode de test.   L'objectif reste de faire dialoguer vos utilisateurs avec le bot via des canaux comme Messenger, Google Assistant...\nou vos sites ou applications.", 
            "title": "L'onglet Test"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#longlet-monitoring", 
            "text": "Il est ensuite possible de consulter la discussion que vous venez d'avoir avec le bot via l'onglet Monitoring   Ici, le canal est indiqu\u00e9 comme \u00e9tant celui de Messenger puisque il a \u00e9t\u00e9 simul\u00e9 une conversation Messenger.", 
            "title": "L'onglet Monitoring"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#longlet-build", 
            "text": "", 
            "title": "L'onglet Build"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#ajouter-une-intention-avec-reponse-specifique", 
            "text": "Via la cat\u00e9gorie  Add new Answer , il est possible d'ajouter du comportement sp\u00e9cifique :   Puis de tester ensuite la nouvelle intention et sa r\u00e9ponse :", 
            "title": "Ajouter une intention avec r\u00e9ponse sp\u00e9cifique"
        }, 
        {
            "location": "/presentation-du-bot-open-data/#modification-des-reponses-et-internationalisation", 
            "text": "Enfin il est possible de modifier chaque r\u00e9ponse du bot par type d'interface (chat/voix), par type de connecteur et par langue\nvia l'onglet  i18n .  Il est aussi possible de rajouter des r\u00e9ponses alternatives ( \u00e0 chaque fois une r\u00e9ponse de la liste sera choisie au hasard) via cette interface.", 
            "title": "Modification des r\u00e9ponses et internationalisation"
        }, 
        {
            "location": "/developper-un-bot/", 
            "text": "Le langage d\u00e9di\u00e9 au conversationnel de Tock\n\n\nPour d\u00e9velopper un bot ou un assistant avec Tock,\nil est n\u00e9cessaire aujourd'hui de d\u00e9velopper dans un \nDomain Specifique Language (DSL)\n \nd\u00e9velopp\u00e9 en \nKotlin\n via un IDE.\n\n\nDans les mois \u00e0 venir, Tock va supporter d'autres langages mais surtout permettre de scripter les r\u00e9ponses\nvia l'interface d'administration. \n\n\nPour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage Kotlin.\n\n\nAjouter la d\u00e9pendance bot-toolkit\n\n\nPour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance \nbot-tookit\n \u00e0 votre projet.\n\n\nAvec Maven :\n\n\n        \ndependency\n\n            \ngroupId\nfr.vsct.tock\n/groupId\n\n            \nartifactId\nbot-toolkit\n/artifactId\n\n            \nversion\n1.1.0\n/version\n\n        \n/dependency\n\n\n\n\n\n\nou Gradle :\n\n\n      compile \nfr.vsct.tock:bot-toolkit:1.1.0\n\n\n\n\n\n\nUn bot est un ensemble de Stories\n\n\nVoici comment le bot open data est d\u00e9fini :\n\n\nval\n \nopenBot\n \n=\n \nbot\n(\n\n        \nbot_open_data\n,\n\n        \nstories\n \n=\n\n        \nlistOf\n(\n\n                \ngreetings\n,\n\n                \ndepartures\n,\n\n                \narrivals\n,\n\n                \nsearch\n\n        \n),\n\n        \nhello\n \n=\n \ngreetings\n\n\n)\n\n\n\n\n\n\nCe bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de \n\"Story\"\n.\n\n\nUne \nStory\n est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle,\n\u00e0 une ou plusieurs intentions dites \"secondaires\".\n\n\nIci le bot d\u00e9finit 4 \nStories\n, greetings, departures, arrivals et search. \n\ngreetings\n est par ailleurs ( \nhello = greetings\n) indiqu\u00e9e comme \u00e9tant la story pr\u00e9sent\u00e9e par d\u00e9faut lors du d\u00e9but d'une conversation.\n\n\nUne Story simple\n\n\nComment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e de la Story \ngreetings\n :\n\n\nval\n \ngreetings\n \n=\n \nstory\n(\ngreetings\n)\n \n{\n\n    \nsend\n(\nBienvenue chez le Bot Open Data Sncf! :)\n)\n\n    \nend\n(\nIl s\nagit d\nun bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\n)\n\n\n}\n\n\n\n\n\n\nNotez que dans le corps de la fonction, \nthis\n est de type \nBotBus\n,\n\u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der\n\u00e0 tous les \u00e9lements contextuels disponibles.\n\n\nConcr\u00e8tement sela signifie que quand l'intention \ngreetings\n sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock.\n\n\nLe bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse (\nbus.send()\n), puis un deuxi\u00e8me en indiquant que c'est \nla derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un \nbus.end()\n.\n\n\nVoici maintenant la version compl\u00e8te de \ngreetings\n :\n\n\nval\n \ngreetings\n \n=\n \nstory\n(\ngreetings\n)\n \n{\n\n    \n//cleanup state\n\n    \nresetDialogState\n()\n\n\n    \nsend\n(\nBienvenue chez le Bot Open Data Sncf! :)\n)\n\n    \nsend\n(\nIl s\nagit d\nun bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\n)\n\n\n    \nwithMessenger\n \n{\n\n        \nbuttonsTemplate\n(\n\n              \nIl est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d\nune gare et constatez le r\u00e9sultat! :) \n,\n\n              \npostbackButton\n(\nItin\u00e9raires\n,\n \nsearch\n),\n\n              \npostbackButton\n(\nD\u00e9parts\n,\n \nDepartures\n),\n\n              \npostbackButton\n(\nArriv\u00e9es\n,\n \nArrivals\n)\n\n        \n)\n\n    \n}\n\n    \nwithGoogleAssistant\n \n{\n\n       \ngaMessage\n(\n\n              \nIl est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d\nune gare et constatez le r\u00e9sultat! :) \n,\n\n              \nItin\u00e9raires\n,\n\n              \nD\u00e9parts\n,\n\n              \nArriv\u00e9es\n)\n\n       \n}\n\n\n    \nend\n()\n\n\n}\n\n\n\n\n\n\nDeux notions ont \u00e9t\u00e9 ajout\u00e9es :\n\n\n\n\n\n\nresetDialogState()\n qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents)\n\n\n\n\n\n\nles m\u00e9thodes \nwithMessenger{}\n et \nwithGoogleAssistant{}\n qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur.\nIci un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.\n\n\n\n\n\n\nAller un peu plus loin\n\n\nBien s\u00fbr, le \nStory Handler\n de \ngreetings\n ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame.\n\n\nPour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.\n\n\nIntentions secondaires\n\n\nVoici le d\u00e9but de la d\u00e9finition de la story \nsearch\n :\n\n\nval\n \nsearch\n \n=\n \nstoryDef\nSearchDef\n(\n\n        \nsearch\n,\n\n        \nsetOf\n(\nindicate_origin\n),\n\n        \nsetOf\n(\nindicate_location\n))\n \n{\n\n\n\n}\n\n\n\n\n\n\nLa story \nsearch\n d\u00e9finit une intention secondaire \n\"de d\u00e9marrage\"\n (\nindicate_origin\n) \net une intention secondaire simple (\nindicate_location\n)\n\n\nUne intention secondaire \n\"de d\u00e9marrage\"\n est semblable en tout point \u00e0 une intention principale : \nd\u00e8s que le mod\u00e8le NLP d\u00e9tecte cette intention, il va ex\u00e9cuter la story \nsearch\n, quel que soit le contexte.\n\n\nPour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte \nest \nd\u00e9j\u00e0\n la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.\n\n\nManipuler les entit\u00e9s\n\n\nPour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des \nextensions\n. \nPar exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9 \ndestination\n:\n\n\nval\n \ndestinationEntity\n \n=\n \nopenBot\n.\nentity\n(\nlocation\n,\n \ndestination\n)\n \n\n\nvar\n \nBotBus\n.\ndestination\n:\n \nPlace\n?\n\n    \nget\n()\n \n=\n \nplace\n(\ndestinationEntity\n)\n\n    \nset\n(\nvalue\n)\n \n=\n \nsetPlace\n(\ndestinationEntity\n,\n \nvalue\n)\n\n\n\nprivate\n \nfun\n \nBotBus\n.\nplace\n(\nentity\n:\n \nEntity\n):\n \nPlace\n?\n \n=\n \nentityValue\n(\nentity\n,\n \n::\nplaceValue\n)\n?.\nplace\n\n\n\nprivate\n \nfun\n \nBotBus\n.\nsetPlace\n(\nentity\n:\n \nEntity\n,\n \nplace\n:\n \nPlace\n?)\n \n=\n \nchangeEntityValue\n(\nentity\n,\n \nplace\n?.\nlet\n \n{\n \nPlaceValue\n(\nplace\n)\n \n})\n\n\n\n\n\n\nUne entit\u00e9 de type \"location\" et de role \"destination\" est cr\u00e9\u00e9e. \nIl s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP.\n\n\nUne variable \ndestination\n est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier.\nCette variable contient la valeur actuelle de la destination dans le contexte utilisateur.\n\n\nVoici une version compl\u00e9t\u00e9e de la story \nsearch\n qui utilise \ndestination\n :\n\n\nval\n \nsearch\n \n=\n \nstoryDef\nSearchDef\n(\n\n        \nsearch\n,\n\n        \nsetOf\n(\nindicate_origin\n),\n\n        \nsetOf\n(\nindicate_location\n))\n \n{\n\n\n        \n//check mandatory entities\n\n        \nwhen\n \n{\n\n            \ndestination\n \n==\n \nnull\n \n-\n \nend\n(\nPour quelle destination?\n)\n\n            \norigin\n \n==\n \nnull\n \n-\n \nend\n(\nPour quelle origine?\n)\n\n            \ndepartureDate\n \n==\n \nnull\n \n-\n \nend\n(\nQuand souhaitez-vous partir?\n)\n\n        \n}\n \n\n}\n\n\n\n\n\n\nSi il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0.\nIdem pour l'origine ou la date de d\u00e9part.\n\n\nSi les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe (\nSearchDef\n).\n\n\nLa version compl\u00e8te de cette premi\u00e8re partie du code est la suivante :\n\n\nval\n \nsearch\n \n=\n \nstoryDef\nSearchDef\n(\n\n        \nsearch\n,\n\n        \nsetOf\n(\nindicate_origin\n),\n\n        \nsetOf\n(\nindicate_location\n))\n \n{\n\n\n        \n//handle generic location intent\n\n        \nif\n \n(\nisIntent\n(\nindicate_location\n)\n \n \nlocation\n \n!=\n \nnull\n)\n \n{\n\n            \nif\n \n(\ndestination\n \n==\n \nnull\n \n||\n \norigin\n \n!=\n \nnull\n)\n \n{\n\n                \ndestination\n \n=\n \nreturnsAndRemoveLocation\n()\n\n            \n}\n \nelse\n \n{\n\n                \norigin\n \n=\n \nreturnsAndRemoveLocation\n()\n\n            \n}\n\n        \n}\n    \n\n        \n//check mandatory entities\n\n        \nwhen\n \n{\n\n            \ndestination\n \n==\n \nnull\n \n-\n \nend\n(\nPour quelle destination?\n)\n\n            \norigin\n \n==\n \nnull\n \n-\n \nend\n(\nPour quelle origine?\n)\n\n            \ndepartureDate\n \n==\n \nnull\n \n-\n \nend\n(\nQuand souhaitez-vous partir?\n)\n\n        \n}\n\n\n}\n\n\n\n\n\n\nDans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est \nindicate_location\n, nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination.\nIl est donc cod\u00e9 une r\u00e8gle simple : \nSi il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination.\nSinon, il s'agit de l'origine. \n\n\nUtiliser HandlerDef\n\n\nDans la d\u00e9finition de la story \nsearch\n ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique \nSearchDef\n. \nVoici le code de cette classe :\n\n\n@GAHandler\n(\nGASearchConnector\n::\nclass\n)\n\n\n@MessengerHandler\n(\nMessengerSearchConnector\n::\nclass\n)\n\n\nclass\n \nSearchDef\n(\nbus\n:\n \nBotBus\n)\n \n:\n \nHandlerDef\nSearchConnector\n(\nbus\n)\n \n{\n\n\n    \nprivate\n \nval\n \nd\n:\n \nPlace\n \n=\n \nbus\n.\ndestination\n!!\n\n    \nprivate\n \nval\n \no\n:\n \nPlace\n \n=\n \nbus\n.\norigin\n!!\n\n    \nprivate\n \nval\n \ndate\n:\n \nLocalDateTime\n \n=\n \nbus\n.\ndepartureDate\n!!\n\n\n    \noverride\n \nfun\n \nanswer\n()\n \n{\n\n        \nsend\n(\nDe {0} \u00e0 {1}\n,\n \no\n,\n \nd\n)\n\n        \nsend\n(\nD\u00e9part le {0}\n,\n \ndate\n \nby\n \ndatetimeFormat\n)\n\n        \nval\n \njourneys\n \n=\n \nSncfOpenDataClient\n.\njourney\n(\no\n,\n \nd\n,\n \ndate\n)\n\n        \nif\n \n(\njourneys\n.\nisEmpty\n())\n \n{\n\n            \nend\n(\nD\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :(\n)\n\n        \n}\n \nelse\n \n{\n\n            \nsend\n(\nVoici la premi\u00e8re proposition :\n)\n\n            \nconnector\n?.\nsendFirstJourney\n(\njourneys\n.\nfirst\n())\n\n            \nend\n()\n\n        \n}\n\n    \n}\n\n\n}\n\n\n\n\n\n\nSearchDef\n \u00e9tend \nHandlerDef\n qui est un alias d'une classe du framework Tock.\n\n\nC'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des \nstories\n complexes. \n\n\nLe code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire, \nSearchConnector\n.\n\n\nSearchConnector\n est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations\n \n@GAHandler(GASearchConnector::class)\n et \n@MessengerHandler(MessengerSearchConnector::class)\n \n indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger).\n\n\nQue se passerait t'il si il n'avait pas de connecteur pour Google Assistant par exemple? \n La m\u00e9thode \nconnector?.sendFirstJourney(journeys.first())\n n'enverrait pas la r\u00e9ponse finale, puisque \nconnector\n serait \nnull\n.\n\n\nUtiliser ConnectorDef\n\n\nVoici maintenant une version simplifi\u00e9e de \nSearchConnector\n :\n\n\nsealed\n \nclass\n \nSearchConnector\n(\ncontext\n:\n \nSearchDef\n)\n \n:\n \nConnectorDef\nSearchDef\n(\ncontext\n)\n \n{\n\n\n    \nfun\n \nSection\n.\ntitle\n():\n \nCharSequence\n \n=\n \ni18n\n(\n{0} - {1}\n,\n \nfrom\n,\n \nto\n)\n\n\n    \nfun\n \nsendFirstJourney\n(\njourney\n:\n \nJourney\n)\n \n=\n \nwithMessage\n(\nsendFirstJourney\n(\njourney\n.\npublicTransportSections\n()))\n\n\n    \nabstract\n \nfun\n \nsendFirstJourney\n(\nsections\n:\n \nList\nSection\n):\n \nConnectorMessage\n\n\n\n}\n\n\n\n\n\n\net son impl\u00e9mentation pour Messenger :\n\n\nclass\n \nMessengerSearchConnector\n(\ncontext\n:\n \nSearchDef\n)\n \n:\n \nSearchConnector\n(\ncontext\n)\n \n{\n\n\n    \noverride\n \nfun\n \nsendFirstJourney\n(\nsections\n:\n \nList\nSection\n):\n \nConnectorMessage\n \n=\n\n          \nflexibleListTemplate\n(\n\n                \nsections\n.\nmap\n \n{\n \nsection\n \n-\n\n                      \nwith\n(\nsection\n)\n \n{\n\n                          \nlistElement\n(\n\n                                \ntitle\n(),\n\n                                \ncontent\n(),\n\n                                \ntrainImage\n\n                          \n)\n\n                      \n}\n\n                \n},\n\n                \ncompact\n\n          \n)\n\n\n}\n\n\n\n\n\n\nLe code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans \nSearchConnector\n et le comportement sp\u00e9cifique \u00e0\nchaque connecteur se trouve dans les classes d\u00e9di\u00e9es.\n\n\nD\u00e9marrer et connecter le bot\n\n\nPour d\u00e9marrer le bot, il suffit de rajouter dans votre \nmain\n principal l'appel suivant:\n\n\nregisterAndInstallBot\n(\nopenBot\n)\n\n\n\n\n\n\no\u00f9 la variable \nopenBot\n est le bot que vous avez d\u00e9fini au d\u00e9part.\n\n\nUne fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s\ndans l'interface d'administration du bot, du menu Configuration -\n Bot Configurations -\n Create a new configuration.\n\n\nLa documentation pour chaque connecteur se trouve dans le README des projects correspondants. Trois sont disponibles \u00e0 l'heure actuelle :\n\n\n\n\nMessenger\n\n\nGoogle Assistant\n\n\nSlack", 
            "title": "D\u00e9velopper un bot"
        }, 
        {
            "location": "/developper-un-bot/#le-langage-dedie-au-conversationnel-de-tock", 
            "text": "Pour d\u00e9velopper un bot ou un assistant avec Tock,\nil est n\u00e9cessaire aujourd'hui de d\u00e9velopper dans un  Domain Specifique Language (DSL)  \nd\u00e9velopp\u00e9 en  Kotlin  via un IDE.  Dans les mois \u00e0 venir, Tock va supporter d'autres langages mais surtout permettre de scripter les r\u00e9ponses\nvia l'interface d'administration.   Pour appr\u00e9hender compl\u00e8tement ce qui va suivre, il est recommand\u00e9 de ma\u00eetriser les bases du langage Kotlin.", 
            "title": "Le langage d\u00e9di\u00e9 au conversationnel de Tock"
        }, 
        {
            "location": "/developper-un-bot/#ajouter-la-dependance-bot-toolkit", 
            "text": "Pour utiliser le framework conversationnel, il faut ajouter la d\u00e9pendance  bot-tookit  \u00e0 votre projet.  Avec Maven :           dependency \n             groupId fr.vsct.tock /groupId \n             artifactId bot-toolkit /artifactId \n             version 1.1.0 /version \n         /dependency   ou Gradle :        compile  fr.vsct.tock:bot-toolkit:1.1.0", 
            "title": "Ajouter la d\u00e9pendance bot-toolkit"
        }, 
        {
            "location": "/developper-un-bot/#un-bot-est-un-ensemble-de-stories", 
            "text": "Voici comment le bot open data est d\u00e9fini :  val   openBot   =   bot ( \n         bot_open_data , \n         stories   = \n         listOf ( \n                 greetings , \n                 departures , \n                 arrivals , \n                 search \n         ), \n         hello   =   greetings  )   Ce bot comporte un identifiant (obligatoire - \"bot_open_data\") et une liste de  \"Story\" .  Une  Story  est un regroupement fonctionnel qui correspond \u00e0 une intention principale et, de mani\u00e8re optionelle,\n\u00e0 une ou plusieurs intentions dites \"secondaires\".  Ici le bot d\u00e9finit 4  Stories , greetings, departures, arrivals et search.  greetings  est par ailleurs (  hello = greetings ) indiqu\u00e9e comme \u00e9tant la story pr\u00e9sent\u00e9e par d\u00e9faut lors du d\u00e9but d'une conversation.", 
            "title": "Un bot est un ensemble de Stories"
        }, 
        {
            "location": "/developper-un-bot/#une-story-simple", 
            "text": "Comment d\u00e9finit-on une Story? Voici une premi\u00e8re version simplifi\u00e9e de la Story  greetings  :  val   greetings   =   story ( greetings )   { \n     send ( Bienvenue chez le Bot Open Data Sncf! :) ) \n     end ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock )  }   Notez que dans le corps de la fonction,  this  est de type  BotBus ,\n\u00e0 partir duquel vous pouvez interagir avec l'utilisateur, et qui permet \u00e9galement d'acc\u00e8der\n\u00e0 tous les \u00e9lements contextuels disponibles.  Concr\u00e8tement sela signifie que quand l'intention  greetings  sera d\u00e9tect\u00e9e par le mod\u00e8le NLP, la fonction ci-dessus sera appel\u00e9e par le framework Tock.  Le bot envoie donc successivement une premi\u00e8re phrase de r\u00e9ponse ( bus.send() ), puis un deuxi\u00e8me en indiquant que c'est \nla derni\u00e8re phrase de sa r\u00e9ponse \u00e0 l'aide d'un  bus.end() .  Voici maintenant la version compl\u00e8te de  greetings  :  val   greetings   =   story ( greetings )   { \n     //cleanup state \n     resetDialogState () \n\n     send ( Bienvenue chez le Bot Open Data Sncf! :) ) \n     send ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) \n\n     withMessenger   { \n         buttonsTemplate ( \n               Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :)  , \n               postbackButton ( Itin\u00e9raires ,   search ), \n               postbackButton ( D\u00e9parts ,   Departures ), \n               postbackButton ( Arriv\u00e9es ,   Arrivals ) \n         ) \n     } \n     withGoogleAssistant   { \n        gaMessage ( \n               Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :)  , \n               Itin\u00e9raires , \n               D\u00e9parts , \n               Arriv\u00e9es ) \n        } \n\n     end ()  }   Deux notions ont \u00e9t\u00e9 ajout\u00e9es :    resetDialogState()  qui permet de repartir d'un contexte utilisateur vide (en oubliant les \u00e9ventuels \u00e9changes pr\u00e9c\u00e9dents)    les m\u00e9thodes  withMessenger{}  et  withGoogleAssistant{}  qui permettent de d\u00e9finir des r\u00e9ponses sp\u00e9cifiques pour chaque connecteur.\nIci un texte avec des boutons pour Messenger, et un texte avec des suggestions pour Google Assistant.", 
            "title": "Une Story simple"
        }, 
        {
            "location": "/developper-un-bot/#aller-un-peu-plus-loin", 
            "text": "Bien s\u00fbr, le  Story Handler  de  greetings  ne d\u00e9pend pas du contexte : la r\u00e9ponse est toujours la m\u00eame.  Pour le d\u00e9veloppement de stories complexes, nous avons besoin d'une abstraction suppl\u00e9mentaire.", 
            "title": "Aller un peu plus loin"
        }, 
        {
            "location": "/developper-un-bot/#intentions-secondaires", 
            "text": "Voici le d\u00e9but de la d\u00e9finition de la story  search  :  val   search   =   storyDef SearchDef ( \n         search , \n         setOf ( indicate_origin ), \n         setOf ( indicate_location ))   {  }   La story  search  d\u00e9finit une intention secondaire  \"de d\u00e9marrage\"  ( indicate_origin ) \net une intention secondaire simple ( indicate_location )  Une intention secondaire  \"de d\u00e9marrage\"  est semblable en tout point \u00e0 une intention principale : \nd\u00e8s que le mod\u00e8le NLP d\u00e9tecte cette intention, il va ex\u00e9cuter la story  search , quel que soit le contexte.  Pour une intention secondaire simple, par contre, la story ne sera ex\u00e9cut\u00e9e que si la story courante du contexte \nest  d\u00e9j\u00e0  la story search. Plusieurs story diff\u00e9rentes peuvent donc partager les m\u00eames intentions secondaires.", 
            "title": "Intentions secondaires"
        }, 
        {
            "location": "/developper-un-bot/#manipuler-les-entites", 
            "text": "Pour r\u00e9cup\u00e9rer les valeurs des entit\u00e9s, une bonne pratique est de d\u00e9finir des  extensions . \nPar exemple voici le code utilis\u00e9 pour r\u00e9cup\u00e9rer l'entit\u00e9  destination :  val   destinationEntity   =   openBot . entity ( location ,   destination )   var   BotBus . destination :   Place ? \n     get ()   =   place ( destinationEntity ) \n     set ( value )   =   setPlace ( destinationEntity ,   value )  private   fun   BotBus . place ( entity :   Entity ):   Place ?   =   entityValue ( entity ,   :: placeValue ) ?. place  private   fun   BotBus . setPlace ( entity :   Entity ,   place :   Place ?)   =   changeEntityValue ( entity ,   place ?. let   {   PlaceValue ( place )   })   Une entit\u00e9 de type \"location\" et de role \"destination\" est cr\u00e9\u00e9e. \nIl s'agit de l'entit\u00e9 correspondante dans le mod\u00e8le NLP.  Une variable  destination  est d\u00e9finie, qui va simplifier la manipulation de cette entit\u00e9 dans le code m\u00e9tier.\nCette variable contient la valeur actuelle de la destination dans le contexte utilisateur.  Voici une version compl\u00e9t\u00e9e de la story  search  qui utilise  destination  :  val   search   =   storyDef SearchDef ( \n         search , \n         setOf ( indicate_origin ), \n         setOf ( indicate_location ))   { \n\n         //check mandatory entities \n         when   { \n             destination   ==   null   -   end ( Pour quelle destination? ) \n             origin   ==   null   -   end ( Pour quelle origine? ) \n             departureDate   ==   null   -   end ( Quand souhaitez-vous partir? ) \n         }   }   Si il n'y a pas de valeur dans le contexte courant pour la destination, le bot demande de sp\u00e9cifier la destination et en reste l\u00e0.\nIdem pour l'origine ou la date de d\u00e9part.  Si les 3 valeurs obligatoires sont sp\u00e9cifi\u00e9es, il passe \u00e0 la r\u00e9ponse proprement dite d\u00e9velopp\u00e9e dans la classe ( SearchDef ).  La version compl\u00e8te de cette premi\u00e8re partie du code est la suivante :  val   search   =   storyDef SearchDef ( \n         search , \n         setOf ( indicate_origin ), \n         setOf ( indicate_location ))   { \n\n         //handle generic location intent \n         if   ( isIntent ( indicate_location )     location   !=   null )   { \n             if   ( destination   ==   null   ||   origin   !=   null )   { \n                 destination   =   returnsAndRemoveLocation () \n             }   else   { \n                 origin   =   returnsAndRemoveLocation () \n             } \n         }     \n\n         //check mandatory entities \n         when   { \n             destination   ==   null   -   end ( Pour quelle destination? ) \n             origin   ==   null   -   end ( Pour quelle origine? ) \n             departureDate   ==   null   -   end ( Quand souhaitez-vous partir? ) \n         }  }   Dans le cas o\u00f9 l'intention d\u00e9tect\u00e9e est  indicate_location , nous ne savons pas si la localit\u00e9 indiqu\u00e9e repr\u00e9sente l'origine ou la destination.\nIl est donc cod\u00e9 une r\u00e8gle simple : \nSi il existe d\u00e9j\u00e0 dans le contexte une origine et pas de destination, la nouvelle localit\u00e9 est en fait la destination.\nSinon, il s'agit de l'origine.", 
            "title": "Manipuler les entit\u00e9s"
        }, 
        {
            "location": "/developper-un-bot/#utiliser-handlerdef", 
            "text": "Dans la d\u00e9finition de la story  search  ci-dessus, vous avez pu noter le typage g\u00e9n\u00e9rique  SearchDef . \nVoici le code de cette classe :  @GAHandler ( GASearchConnector :: class )  @MessengerHandler ( MessengerSearchConnector :: class )  class   SearchDef ( bus :   BotBus )   :   HandlerDef SearchConnector ( bus )   { \n\n     private   val   d :   Place   =   bus . destination !! \n     private   val   o :   Place   =   bus . origin !! \n     private   val   date :   LocalDateTime   =   bus . departureDate !! \n\n     override   fun   answer ()   { \n         send ( De {0} \u00e0 {1} ,   o ,   d ) \n         send ( D\u00e9part le {0} ,   date   by   datetimeFormat ) \n         val   journeys   =   SncfOpenDataClient . journey ( o ,   d ,   date ) \n         if   ( journeys . isEmpty ())   { \n             end ( D\u00e9sol\u00e9, aucun itin\u00e9raire trouv\u00e9 :( ) \n         }   else   { \n             send ( Voici la premi\u00e8re proposition : ) \n             connector ?. sendFirstJourney ( journeys . first ()) \n             end () \n         } \n     }  }   SearchDef  \u00e9tend  HandlerDef  qui est un alias d'une classe du framework Tock.  C'est en g\u00e9n\u00e9ral ici que l'on va d\u00e9finir le code m\u00e9tier des  stories  complexes.   Le code est relativement parlant, mais il contient une abstraction suppl\u00e9mentaire,  SearchConnector .  SearchConnector  est la classe qui d\u00e9finit le comportement sp\u00e9cifique \u00e0 chaque connecteur, et les annotations\n  @GAHandler(GASearchConnector::class)  et  @MessengerHandler(MessengerSearchConnector::class)  \n indiquent les impl\u00e9mentations correspondantes pour les diff\u00e9rents connecteurs support\u00e9s (respectivement Google Assistant et Messenger).  Que se passerait t'il si il n'avait pas de connecteur pour Google Assistant par exemple? \n La m\u00e9thode  connector?.sendFirstJourney(journeys.first())  n'enverrait pas la r\u00e9ponse finale, puisque  connector  serait  null .", 
            "title": "Utiliser HandlerDef"
        }, 
        {
            "location": "/developper-un-bot/#utiliser-connectordef", 
            "text": "Voici maintenant une version simplifi\u00e9e de  SearchConnector  :  sealed   class   SearchConnector ( context :   SearchDef )   :   ConnectorDef SearchDef ( context )   { \n\n     fun   Section . title ():   CharSequence   =   i18n ( {0} - {1} ,   from ,   to ) \n\n     fun   sendFirstJourney ( journey :   Journey )   =   withMessage ( sendFirstJourney ( journey . publicTransportSections ())) \n\n     abstract   fun   sendFirstJourney ( sections :   List Section ):   ConnectorMessage  }   et son impl\u00e9mentation pour Messenger :  class   MessengerSearchConnector ( context :   SearchDef )   :   SearchConnector ( context )   { \n\n     override   fun   sendFirstJourney ( sections :   List Section ):   ConnectorMessage   = \n           flexibleListTemplate ( \n                 sections . map   {   section   - \n                       with ( section )   { \n                           listElement ( \n                                 title (), \n                                 content (), \n                                 trainImage \n                           ) \n                       } \n                 }, \n                 compact \n           )  }   Le code sp\u00e9cifique \u00e0 chaque connecteur est ainsi correctement d\u00e9coupl\u00e9. Le code commun \u00e0 chaque connecteur est pr\u00e9sent dans  SearchConnector  et le comportement sp\u00e9cifique \u00e0\nchaque connecteur se trouve dans les classes d\u00e9di\u00e9es.", 
            "title": "Utiliser ConnectorDef"
        }, 
        {
            "location": "/developper-un-bot/#demarrer-et-connecter-le-bot", 
            "text": "Pour d\u00e9marrer le bot, il suffit de rajouter dans votre  main  principal l'appel suivant:  registerAndInstallBot ( openBot )   o\u00f9 la variable  openBot  est le bot que vous avez d\u00e9fini au d\u00e9part.  Une fois le bot d\u00e9marr\u00e9, il est \u00e9galement n\u00e9cessaire de sp\u00e9cifier quels connecteurs sont utilis\u00e9s\ndans l'interface d'administration du bot, du menu Configuration -  Bot Configurations -  Create a new configuration.  La documentation pour chaque connecteur se trouve dans le README des projects correspondants. Trois sont disponibles \u00e0 l'heure actuelle :   Messenger  Google Assistant  Slack", 
            "title": "D\u00e9marrer et connecter le bot"
        }, 
        {
            "location": "/tester-le-bot/", 
            "text": "Utiliser le framework de test\n\n\nTock met \u00e0 disposition des extensions pour tester le bot unitairement.\n\n\nPour les utiliser, il est n\u00e9cessaire d'ajouter la librairie \nbot-test\n \u00e0 votre projet.\n\n\nAvec Maven :\n\n\n        \ndependency\n\n            \ngroupId\nfr.vsct.tock\n/groupId\n\n            \nartifactId\nbot-test\n/artifactId\n\n            \nversion\n1.1.0\n/version\n\n            \nscope\ntest\n/scope\n\n        \n/dependency\n\n\n\n\n\n\nou Gradle :\n\n\n      testCompile \nfr.vsct.tock:bot-test:1.1.0\n\n\n\n\n\n\nL'ensemble de ce framework est document\u00e9 au format KDoc \nici\n.\n\n\nEcrire un test simple\n\n\nL'ensemble des exemples suivants utilisent \nJUnit5\n. \nUne extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est \ndisponible\n.\n\n\n    \n@RegisterExtension\n\n    \n@JvmField\n\n    \nval\n \next\n \n=\n \nTockJUnit5Extension\n()\n\n\n\n\n\n\nAfin de tester la story \ngreetings\n du bot Open Data, il suffit d'utiliser la m\u00e9thode \next.send()\n\n qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi :   \n\n\n    \n@Test\n\n    \nfun\n \n`\ngreetings\n \nstory\n \ndisplays\n \nwelcome\n \nmessage\n \nWHEN\n \nlocale\n \nis\n \nfr\n`\n()\n \n{\n\n        \next\n.\nsend\n(\nlocale\n \n=\n \nLocale\n.\nFRENCH\n)\n \n{\n\n            \nfirstAnswer\n.\nassertText\n(\nBienvenue chez le Bot Open Data Sncf! :)\n)\n\n            \nsecondAnswer\n.\nassertText\n(\nIl s\nagit d\nun bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\n)\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nComme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger : \n\n\n    \nlastAnswer\n.\nassertMessage\n(\n\n                \nbuttonsTemplate\n(\n\n                    \nIl est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d\nune gare et constatez le r\u00e9sultat! :)\n,\n\n                    \npostbackButton\n(\nItin\u00e9raires\n,\n \nsearch\n),\n\n                    \npostbackButton\n(\nD\u00e9parts\n,\n \nDepartures\n),\n\n                    \npostbackButton\n(\nArriv\u00e9es\n,\n \nArrivals\n)\n\n                \n)\n\n            \n)\n\n\n\n\n\n\nPour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur),\n il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester :\n\n\n    \next\n.\nsend\n(\nconnectorType\n \n=\n \ngaConnectorType\n,\n \nlocale\n \n=\n \nLocale\n.\nFRENCH\n)\n \n{\n\n            \nfirstAnswer\n.\nassertText\n(\nBienvenue chez le Bot Open Data Sncf! :)\n)\n\n            \nsecondAnswer\n.\nassertText\n(\nIl s\nagit d\nun bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock\n)\n\n            \nlastAnswer\n.\nassertMessage\n(\n\n                \ngaMessage\n(\n\n                    \nIl est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d\nune gare et constatez le r\u00e9sultat! :)\n,\n\n                    \nItin\u00e9raires\n,\n\n                    \nD\u00e9parts\n,\n\n                    \nArriv\u00e9es\n\n                \n)\n\n            \n)\n\n        \n}\n\n\n\n\n\n\nTester une Story sp\u00e9cifique\n\n\nDans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester (\ngreetings\n \u00e9tant la story par d\u00e9faut).\nSupposons que nous souhaitons la story \nsearch\n, nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante  : \n\n\n    \n@Test\n\n    \nfun\n \n`\nsearch\n \nstory\n \nasks\n \nfor\n \ndestination\n \nWHEN\n \nthere\n \nis\n \nno\n \ndestination\n \nin\n \ncontext\n`\n()\n \n{\n\n        \next\n.\nsend\n(\nintent\n \n=\n \nsearch\n,\n \nlocale\n \n=\n \nLocale\n.\nFRENCH\n)\n \n{\n\n            \nfirstAnswer\n.\nassertText\n(\nPour quelle destination?\n)\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nTester un dialogue\n\n\nIl est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine :\n\n\n    \n@Test\n\n    \nfun\n \n`\nsearch\n \nstory\n \nasks\n \nfor\n \norigin\n \nWHEN\n \nthere\n \nis\n \na\n \ndestination\n \nbut\n \nno\n \norigin\n \nin\n \ncontext\n`\n()\n \n{\n\n        \next\n.\nsend\n(\nJe voudrais rechercher un itin\u00e9raire\n,\n \nsearch\n,\n \nlocale\n \n=\n \nLocale\n.\nFRENCH\n)\n \n{\n\n            \nfirstAnswer\n.\nassertText\n(\nPour quelle destination?\n)\n\n        \n}\n\n        \next\n.\nsend\n(\nLille\n,\n \nindicate_location\n,\n \nlocationEntity\n \nsetTo\n \nlille\n)\n \n{\n\n            \nfirstBusAnswer\n.\nassertText\n(\nPour quelle origine?\n)\n\n        \n}\n\n        \next\n.\nsend\n(\nParis\n,\n \nindicate_location\n,\n \nlocationEntity\n \nsetTo\n \nparis\n)\n \n{\n\n            \nfirstBusAnswer\n.\nassertText\n(\nQuand souhaitez-vous partir?\n)\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nLe texte en premier param\u00e8tre de la m\u00e9thode \nsend\n est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests.\nLes param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase.\nPar exemple : \n\n\n    \nprivate\n \nval\n \nlille\n \n=\n \nPlaceValue\n(\n\n        \nSncfPlace\n(\n\n            \nstop_area\n,\n\n            \n90\n,\n\n            \nLille Europe\n,\n\n            \nLille Europe (Lille)\n,\n\n            \nstop_area:OCE:SA:87223263\n,\n\n            \nCoordinates\n(\n50.638861\n,\n \n3.075774\n)\n\n        \n)\n\n    \n)\n\n\n    \next\n.\nsend\n(\nLille\n,\n \nindicate_location\n,\n \nlocationEntity\n \nsetTo\n \nlille\n)\n\n\n\n\n\n\npermet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention \nindicate_location\n et avec une valeur \npour l'entit\u00e9 \nlocation\n qui va \u00eatre la localisation \nlille\n\n\nEnfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire \nindicate_location\n\nafin d'indiquer l'origine : \n\n\n    \n@Test\n\n    \nfun\n \n`\nsearch\n \nstory\n \nasks\n \nfor\n \ndeparture\n \ndate\n \nWHEN\n \nthere\n \nis\n \na\n \ndestination\n \nand\n \nan\n \norigin\n \nbut\n \nno\n \ndeparture\n \ndate\n \nin\n \ncontext\n`\n()\n \n{\n\n        \next\n.\nnewRequest\n(\nRecherche\n,\n \nsearch\n,\n \nlocale\n \n=\n \nLocale\n.\nFRENCH\n)\n \n{\n\n            \ndestination\n \n=\n \nlille\n\n            \norigin\n \n=\n \nparis\n\n\n            \nrun\n()\n\n\n            \nfirstAnswer\n.\nassertText\n(\nQuand souhaitez-vous partir?\n)\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nLes variables \norigin\n et \ndestination\n sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction \nrun()\n.", 
            "title": "Tester le bot"
        }, 
        {
            "location": "/tester-le-bot/#utiliser-le-framework-de-test", 
            "text": "Tock met \u00e0 disposition des extensions pour tester le bot unitairement.  Pour les utiliser, il est n\u00e9cessaire d'ajouter la librairie  bot-test  \u00e0 votre projet.  Avec Maven :           dependency \n             groupId fr.vsct.tock /groupId \n             artifactId bot-test /artifactId \n             version 1.1.0 /version \n             scope test /scope \n         /dependency   ou Gradle :        testCompile  fr.vsct.tock:bot-test:1.1.0   L'ensemble de ce framework est document\u00e9 au format KDoc  ici .", 
            "title": "Utiliser le framework de test"
        }, 
        {
            "location": "/tester-le-bot/#ecrire-un-test-simple", 
            "text": "L'ensemble des exemples suivants utilisent  JUnit5 . \nUne extension d\u00e9di\u00e9e \u00e0 Tock et JUnit5 est  disponible .       @RegisterExtension \n     @JvmField \n     val   ext   =   TockJUnit5Extension ()   Afin de tester la story  greetings  du bot Open Data, il suffit d'utiliser la m\u00e9thode  ext.send() \n qui permet d'obtenir un mock du bus conversationnel. Le test unitaire s'\u00e9crit alors ainsi :          @Test \n     fun   ` greetings   story   displays   welcome   message   WHEN   locale   is   fr ` ()   { \n         ext . send ( locale   =   Locale . FRENCH )   { \n             firstAnswer . assertText ( Bienvenue chez le Bot Open Data Sncf! :) ) \n             secondAnswer . assertText ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) \n         } \n     }   Comme le connector par d\u00e9faut est celui de Messenger, il est possible de tester de la m\u00eame mani\u00e8re le message sp\u00e9cifique \u00e0 Messenger :        lastAnswer . assertMessage ( \n                 buttonsTemplate ( \n                     Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , \n                     postbackButton ( Itin\u00e9raires ,   search ), \n                     postbackButton ( D\u00e9parts ,   Departures ), \n                     postbackButton ( Arriv\u00e9es ,   Arrivals ) \n                 ) \n             )   Pour tester le message sp\u00e9cifique \u00e0 Google Assistant (ou tout autre connecteur),\n il est n\u00e9cessaire de sp\u00e9cifier le connecteur que l'on souhaite tester :       ext . send ( connectorType   =   gaConnectorType ,   locale   =   Locale . FRENCH )   { \n             firstAnswer . assertText ( Bienvenue chez le Bot Open Data Sncf! :) ) \n             secondAnswer . assertText ( Il s agit d un bot de d\u00e9monstration du framework Tock : https://github.com/voyages-sncf-technologies/tock ) \n             lastAnswer . assertMessage ( \n                 gaMessage ( \n                     Il est volontairement tr\u00e8s limit\u00e9, mais demandez lui un itin\u00e9raire ou les d\u00e9parts \u00e0 partir d une gare et constatez le r\u00e9sultat! :) , \n                     Itin\u00e9raires , \n                     D\u00e9parts , \n                     Arriv\u00e9es \n                 ) \n             ) \n         }", 
            "title": "Ecrire un test simple"
        }, 
        {
            "location": "/tester-le-bot/#tester-une-story-specifique", 
            "text": "Dans les exemples pr\u00e9c\u00e9dents, il n'\u00e9tait pas n\u00e9cessaire d'indiquer la story \u00e0 tester ( greetings  \u00e9tant la story par d\u00e9faut).\nSupposons que nous souhaitons la story  search , nous devons pr\u00e9ciser la story \u00e0 tester de la mani\u00e8re suivante  :        @Test \n     fun   ` search   story   asks   for   destination   WHEN   there   is   no   destination   in   context ` ()   { \n         ext . send ( intent   =   search ,   locale   =   Locale . FRENCH )   { \n             firstAnswer . assertText ( Pour quelle destination? ) \n         } \n     }", 
            "title": "Tester une Story sp\u00e9cifique"
        }, 
        {
            "location": "/tester-le-bot/#tester-un-dialogue", 
            "text": "Il est possible de simuler un dialogue complet. Par exemple, on simule ici que l'utilisateur indique la destination, puis l'origine :       @Test \n     fun   ` search   story   asks   for   origin   WHEN   there   is   a   destination   but   no   origin   in   context ` ()   { \n         ext . send ( Je voudrais rechercher un itin\u00e9raire ,   search ,   locale   =   Locale . FRENCH )   { \n             firstAnswer . assertText ( Pour quelle destination? ) \n         } \n         ext . send ( Lille ,   indicate_location ,   locationEntity   setTo   lille )   { \n             firstBusAnswer . assertText ( Pour quelle origine? ) \n         } \n         ext . send ( Paris ,   indicate_location ,   locationEntity   setTo   paris )   { \n             firstBusAnswer . assertText ( Quand souhaitez-vous partir? ) \n         } \n     }   Le texte en premier param\u00e8tre de la m\u00e9thode  send  est simplement indicatif, pour aider \u00e0 la compr\u00e9hension des tests.\nLes param\u00e8tres suivants permettent de d\u00e9finir comment le NLP va analyser la phrase.\nPar exemple :        private   val   lille   =   PlaceValue ( \n         SncfPlace ( \n             stop_area , \n             90 , \n             Lille Europe , \n             Lille Europe (Lille) , \n             stop_area:OCE:SA:87223263 , \n             Coordinates ( 50.638861 ,   3.075774 ) \n         ) \n     ) \n\n     ext . send ( Lille ,   indicate_location ,   locationEntity   setTo   lille )   permet d'indiquer que la phrase \"Lille\" est cat\u00e9goris\u00e9e comme une intention  indicate_location  et avec une valeur \npour l'entit\u00e9  location  qui va \u00eatre la localisation  lille  Enfin il est possible de modifier toutes les valeurs du bus mock\u00e9 \u00e0 l'initialisation. Dans l'exemple suivant, on simule l'intention secondaire  indicate_location \nafin d'indiquer l'origine :        @Test \n     fun   ` search   story   asks   for   departure   date   WHEN   there   is   a   destination   and   an   origin   but   no   departure   date   in   context ` ()   { \n         ext . newRequest ( Recherche ,   search ,   locale   =   Locale . FRENCH )   { \n             destination   =   lille \n             origin   =   paris \n\n             run () \n\n             firstAnswer . assertText ( Quand souhaitez-vous partir? ) \n         } \n     }   Les variables  origin  et  destination  sont mises \u00e0 jour, puis un appel au bus est simul\u00e9 avec la fonction  run() .", 
            "title": "Tester un dialogue"
        }, 
        {
            "location": "/i18n/", 
            "text": "Traduire et moduler les r\u00e9ponses du bot\n\n\nActivation\n\n\nLa framework Tock met \u00e0 disposition un framework complet d'internationalisation.\nIl est d\u00e9sactiv\u00e9 par d\u00e9faut.\n\n\nPour l'activer, il est n\u00e9cessaire d'utiliser ce code lors du d\u00e9marrage du bot :\n\n\n    \nTranslator\n.\nenabled\n \n=\n \ntrue\n\n\n\n\n\n\nou de passer la propri\u00e9t\u00e9 \n-Dtock_i18n_enabled=true\n \u00e0 la JVM.\n\n\nUtilisation dans le code\n\n\nPrincipe de fonctionnement\n\n\nLe code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple : \n\n\n     \nsend\n(\nArrival at {0}\n,\n \ntime\n)\n\n\n\n\n\n\nest un code valide que le module soit activ\u00e9 ou non. \n\n\nPar contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement.\n\n\nSi l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es :\n\n\n\n\n\n\nUne cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot)\n et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0 \napp_arrivals_arrival_at_\n o\u00f9 \napp\n est le namespace et \n\narrivals\n l'intention principale de la story.\n\n\n\n\n\n\nTock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base. \n\n\n\n\nSi c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la locale demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte)\n\n\nSinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la locale courante\n\n\n\n\n\n\n\n\nIl est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :   \n\n\n\n\n\n\n\n\nFormat support\u00e9\n\n\nLe format support\u00e9 est celui du support i18n de java, en particulier celui de la classe \nMessageFormat\n\nen java. Cela inclut le support de \nChoiceFormat\n :\n\n\n    \nsend\n(\nThere {0,choice,0#are no files|1#is one file|1\nare {0,number,integer} files}.\n,\n \n2\n)\n  \n\n\n\n\n\nPar ailleurs, Tock met \u00e0 disposition une extension \nby\n pour les dates qui permet d'indiquer un format dans les param\u00e8tres :\n\n\n    \nsend\n(\nDeparture at {0}\n,\n \ndepartureDateTime\n \nby\n \ntimeFormat\n)\n \n\n\n\n\n\nLocale de l'utilisateur\n\n\n\n\nQuand c'est possible, la locale de l'utilisateur est import\u00e9e de celle de son compte. \n\n\n\n\nPar exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en fran\u00e7ais, le fran\u00e7ais sera automatiquement\n utilis\u00e9 comme locale par Tock.\n\n\n\n\n\n\nSi il n'y a pas d'indication de locale, c'est la valeur \ndefaultLocale\n qui est pris en compte.\n  Il est possible de modifier cette valeur par d\u00e9faut avec la propri\u00e9t\u00e9 \n-Dtock_default_locale=fr\n\n\n\n\n\n\nEnfin il est possible de modifier la locale de l'utilisateur dans le bot lui-m\u00eame : \n\n\n\n\n\n\n    \nuserPreferences\n.\nlocale\n \n=\n \nLocale\n.\nFRENCH\n\n\n\n\n\n\nPoints d'attention\n\n\n\n\nLe module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin,\n sont \u00e0 bannir sous peine de mauvaises surprises.\n\n\n\n\nPar exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9.\n\n\n    \nsend\n(\nThere are $nb files\n)\n \n//DANGER!! \n\n\n\n\n\n\nmais pose probl\u00e8me si il est activ\u00e9. En effet, les chiffres \u00e9tant supprim\u00e9s de la cl\u00e9 g\u00e9n\u00e9r\u00e9e, le libell\u00e9 traduit sera toujours\n le m\u00eame quel que soit la valeur de la variable \nnb\n !\n\n\nSi il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez \nles m\u00e9thodes \nBotBus.sendRaw\n, \nBotBus.endRaw\n ou \nString.raw\n\n\n    \nsend\n(\nThere are $nb files\n.\nraw\n)\n \n//CORRECT \n\n\n\n\n\n\n    \nsend\n(\nThere are {0} files\n,\n \nnb\n)\n \n//FORMAT A SUIVRE \n\n\n\n\n\n\n\n\nLe risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. \nSi vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode \ni18nKey\n :\n\n\n\n\n    \nsend\n(\ni18nKey\n(\nmy_unique_key\n,\n \nThere are {0} files\n,\n \nnb\n))\n \n\n\n\n\n\nTester l'internationalisation\n\n\nUn exemple de dispositif de test est disponible dans le\n\ncode source du bot d'exemple\n\nIl est n\u00e9cessaire d'\u00e9tendre \nl'extension de test\n\npour ensuite indiquer la \ncorrespondance des libell\u00e9s\n \u00e0 tester.\n\n\nIl ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e : \n\n\n    \n@Test\n\n    \nfun\n \n`\nsearch\n \nstory\n \nasks\n \nfor\n \ndeparture\n \ndate\n \nWHEN\n \nthere\n \nis\n \na\n \ndestination\n \nand\n \nan\n \norigin\n \nbut\n \nno\n \ndeparture\n \ndate\n \nin\n \ncontext\n`\n()\n \n{\n\n        \next\n.\nnewRequest\n(\nRecherche\n,\n \nsearch\n,\n \nlocale\n \n=\n \nLocale\n.\nFRENCH\n)\n \n{\n\n            \ndestination\n \n=\n \nlille\n\n            \norigin\n \n=\n \nparis\n\n\n            \nrun\n()\n\n\n            \nfirstAnswer\n.\nassertText\n(\nQuand souhaitez-vous partir?\n)\n\n        \n}\n\n    \n}\n\n\n\n\n\n\nInterface d'administration\n\n\nLes diff\u00e9rentes variantes\n\n\nChaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot.\n\n\nIl est aussi possible d'indiquer des r\u00e9ponses sp\u00e9cifiques :\n\n\n\n\npar type de connecteur (Messenger, Google Assistant, Slack, etc.)\n\n\npar type d'interface (Texte ou voix) - c'est utile par exemple dans le cas de Google Assistant pour supporter les cas\n des parcours voix uniquement.\n\n\n\n\nEnfin, vous pouvez sp\u00e9cifier des \nalternatives\n.\nDans ce cas, le bot utilise une des alternatives possible au hasard, \u00e0 chaque fois qu'il envoie une r\u00e9ponse \u00e0 l'utilisateur.\n\n\nImport et export des donn\u00e9es\n\n\nUne fonctionnalit\u00e9 d'import et d'export des libell\u00e9s au format json ou csv est disponible. Dans le cas d'un import, seuls les\nlibell\u00e9s indiqu\u00e9s comme \nvalid\u00e9s\n sont pris en compte.", 
            "title": "i18n"
        }, 
        {
            "location": "/i18n/#traduire-et-moduler-les-reponses-du-bot", 
            "text": "", 
            "title": "Traduire et moduler les r\u00e9ponses du bot"
        }, 
        {
            "location": "/i18n/#activation", 
            "text": "La framework Tock met \u00e0 disposition un framework complet d'internationalisation.\nIl est d\u00e9sactiv\u00e9 par d\u00e9faut.  Pour l'activer, il est n\u00e9cessaire d'utiliser ce code lors du d\u00e9marrage du bot :       Translator . enabled   =   true   ou de passer la propri\u00e9t\u00e9  -Dtock_i18n_enabled=true  \u00e0 la JVM.", 
            "title": "Activation"
        }, 
        {
            "location": "/i18n/#utilisation-dans-le-code", 
            "text": "", 
            "title": "Utilisation dans le code"
        }, 
        {
            "location": "/i18n/#principe-de-fonctionnement", 
            "text": "Le code ne change pas une fois l'internationalisation activ\u00e9e. Par exemple :         send ( Arrival at {0} ,   time )   est un code valide que le module soit activ\u00e9 ou non.   Par contre, \u00e0 l'ex\u00e9cution, le comportement diff\u00e8re significativement.  Si l'internationalisation est activ\u00e9e, les op\u00e9rations suivantes vont \u00eatre effectu\u00e9es :    Une cl\u00e9 va \u00eatre g\u00e9n\u00e9r\u00e9e \u00e0 partir du texte pass\u00e9 en param\u00e8tre, en fonction du namespace (l'organisation du cr\u00e9ateur du bot)\n et de la story dans laquelle est demand\u00e9 ce libell\u00e9. Dans le cas ci-dessus, cela devrait ressembler \u00e0  app_arrivals_arrival_at_  o\u00f9  app  est le namespace et  arrivals  l'intention principale de la story.    Tock v\u00e9rifie ensuite si cette cl\u00e9 est d\u00e9j\u00e0 pr\u00e9sente en base.    Si c'est le cas, il utilise le libell\u00e9 pr\u00e9sent en base pour la locale demand\u00e9e afin de trouver la traduction la plus appropri\u00e9e (le connecteur ou le type d'interface peuvent \u00e9galement \u00eatre pris en compte)  Sinon, une cl\u00e9 est cr\u00e9\u00e9e en base avec le libell\u00e9 par d\u00e9faut (\"Arrival at {0}\" dans notre exemple) utilis\u00e9e pour la locale courante     Il est ensuite possible de consulter et de modifier ce libell\u00e9 dans l'interface d'administration :", 
            "title": "Principe de fonctionnement"
        }, 
        {
            "location": "/i18n/#format-supporte", 
            "text": "Le format support\u00e9 est celui du support i18n de java, en particulier celui de la classe  MessageFormat \nen java. Cela inclut le support de  ChoiceFormat  :       send ( There {0,choice,0#are no files|1#is one file|1 are {0,number,integer} files}. ,   2 )     Par ailleurs, Tock met \u00e0 disposition une extension  by  pour les dates qui permet d'indiquer un format dans les param\u00e8tres :       send ( Departure at {0} ,   departureDateTime   by   timeFormat )", 
            "title": "Format support\u00e9"
        }, 
        {
            "location": "/i18n/#locale-de-lutilisateur", 
            "text": "Quand c'est possible, la locale de l'utilisateur est import\u00e9e de celle de son compte.    Par exemple, si le compte d'un utilisateur Messenger est configur\u00e9 en fran\u00e7ais, le fran\u00e7ais sera automatiquement\n utilis\u00e9 comme locale par Tock.    Si il n'y a pas d'indication de locale, c'est la valeur  defaultLocale  qui est pris en compte.\n  Il est possible de modifier cette valeur par d\u00e9faut avec la propri\u00e9t\u00e9  -Dtock_default_locale=fr    Enfin il est possible de modifier la locale de l'utilisateur dans le bot lui-m\u00eame :          userPreferences . locale   =   Locale . FRENCH", 
            "title": "Locale de l'utilisateur"
        }, 
        {
            "location": "/i18n/#points-dattention", 
            "text": "Le module d'internationalisation de Tock est efficace, mais certaines pratiques, pourtant intuitives en Kotlin,\n sont \u00e0 bannir sous peine de mauvaises surprises.   Par exemple, ce code fonctionne parfaitement bien avec le module i18n d\u00e9sactiv\u00e9.       send ( There are $nb files )   //DANGER!!    mais pose probl\u00e8me si il est activ\u00e9. En effet, les chiffres \u00e9tant supprim\u00e9s de la cl\u00e9 g\u00e9n\u00e9r\u00e9e, le libell\u00e9 traduit sera toujours\n le m\u00eame quel que soit la valeur de la variable  nb  !  Si il est n\u00e9cessaire d'envoyer des r\u00e9ponses \"\u00e0 ne pas traduire\", utilisez \nles m\u00e9thodes  BotBus.sendRaw ,  BotBus.endRaw  ou  String.raw       send ( There are $nb files . raw )   //CORRECT         send ( There are {0} files ,   nb )   //FORMAT A SUIVRE     Le risque de collision entre deux libell\u00e9s est faible puisque l'intention principale de la story fait partie de la cl\u00e9. \nSi vous souhaitez cependant \u00e9viter tout risque, vous pouvez utiliser la m\u00e9thode  i18nKey  :        send ( i18nKey ( my_unique_key ,   There are {0} files ,   nb ))", 
            "title": "Points d'attention"
        }, 
        {
            "location": "/i18n/#tester-linternationalisation", 
            "text": "Un exemple de dispositif de test est disponible dans le code source du bot d'exemple \nIl est n\u00e9cessaire d'\u00e9tendre  l'extension de test \npour ensuite indiquer la  correspondance des libell\u00e9s  \u00e0 tester.  Il ne reste plus qu'\u00e0 indiquer la locale souhait\u00e9e :        @Test \n     fun   ` search   story   asks   for   departure   date   WHEN   there   is   a   destination   and   an   origin   but   no   departure   date   in   context ` ()   { \n         ext . newRequest ( Recherche ,   search ,   locale   =   Locale . FRENCH )   { \n             destination   =   lille \n             origin   =   paris \n\n             run () \n\n             firstAnswer . assertText ( Quand souhaitez-vous partir? ) \n         } \n     }", 
            "title": "Tester l'internationalisation"
        }, 
        {
            "location": "/i18n/#interface-dadministration", 
            "text": "", 
            "title": "Interface d'administration"
        }, 
        {
            "location": "/i18n/#les-differentes-variantes", 
            "text": "Chaque libell\u00e9 a une valeur par d\u00e9faut pour chaque langue du bot.  Il est aussi possible d'indiquer des r\u00e9ponses sp\u00e9cifiques :   par type de connecteur (Messenger, Google Assistant, Slack, etc.)  par type d'interface (Texte ou voix) - c'est utile par exemple dans le cas de Google Assistant pour supporter les cas\n des parcours voix uniquement.   Enfin, vous pouvez sp\u00e9cifier des  alternatives .\nDans ce cas, le bot utilise une des alternatives possible au hasard, \u00e0 chaque fois qu'il envoie une r\u00e9ponse \u00e0 l'utilisateur.", 
            "title": "Les diff\u00e9rentes variantes"
        }, 
        {
            "location": "/i18n/#import-et-export-des-donnees", 
            "text": "Une fonctionnalit\u00e9 d'import et d'export des libell\u00e9s au format json ou csv est disponible. Dans le cas d'un import, seuls les\nlibell\u00e9s indiqu\u00e9s comme  valid\u00e9s  sont pris en compte.", 
            "title": "Import et export des donn\u00e9es"
        }, 
        {
            "location": "/kdoc/", 
            "text": "La documentation KDoc est \nmise \u00e0 disposition\n.", 
            "title": "KDoc"
        }, 
        {
            "location": "/contribuer/", 
            "text": "Contribuer au projet tock\n\n\nConstruire le projet\n\n\nLe projet utilise \nMaven\n. \n\n\nIl est n\u00e9cessaire d'utiliser un jdk8 lors du build\n (les jvm de 8 \u00e0 10 sont support\u00e9es \u00e0 l'ex\u00e9cution).\n\n\nmvn package\n\n\nUn build d'int\u00e9gration continue est disponible sur \nTravis\n.\n\n\nLancer le projet  dans l'IDE\n\n\nOutre les \nimages docker\n,\ndes configurations IntelliJ sont disponibles :\n\n\n\n\nLe serveur d'administration du bot : \nBotAdmin\n \n\n\nLe serveur d'administration du NLP uniquement : \nAdmin\n \n\n\nLe service NLP : \nNlpService\n\n\nLe service Duckling : \nDuckling\n\n\nLe service de construction des mod\u00e8les NLP : \nBuildWorker\n\n\nLe service de compilation des scripts : \nKotlinCompilerServer\n\n\n\n\nPour le bot d'exemple :\n\n\n\n\nOpenDataBot\n\n\n\n\nEnfin pour lancer les interfaces d'administration, vous aurez besoin d'un \nnode v6\n\net de lancer les commandes suivantes dans les r\u00e9pertoires\n\n\n\n\npour l'administration compl\u00e8tre : bot/admin/web\n\n\npour l'administration NLP uniquement : nlp/admin/web\n\n\n\n\nnpm install\nng serve\n\n\n\n\n\nCode conventions\n\n\nThe format to follow is described in \nKotlin Code Conventions", 
            "title": "Contribuer au projet"
        }, 
        {
            "location": "/contribuer/#contribuer-au-projet-tock", 
            "text": "", 
            "title": "Contribuer au projet tock"
        }, 
        {
            "location": "/contribuer/#construire-le-projet", 
            "text": "Le projet utilise  Maven .   Il est n\u00e9cessaire d'utiliser un jdk8 lors du build\n (les jvm de 8 \u00e0 10 sont support\u00e9es \u00e0 l'ex\u00e9cution).  mvn package  Un build d'int\u00e9gration continue est disponible sur  Travis .", 
            "title": "Construire le projet"
        }, 
        {
            "location": "/contribuer/#lancer-le-projet-dans-lide", 
            "text": "Outre les  images docker ,\ndes configurations IntelliJ sont disponibles :   Le serveur d'administration du bot :  BotAdmin    Le serveur d'administration du NLP uniquement :  Admin    Le service NLP :  NlpService  Le service Duckling :  Duckling  Le service de construction des mod\u00e8les NLP :  BuildWorker  Le service de compilation des scripts :  KotlinCompilerServer   Pour le bot d'exemple :   OpenDataBot   Enfin pour lancer les interfaces d'administration, vous aurez besoin d'un  node v6 \net de lancer les commandes suivantes dans les r\u00e9pertoires   pour l'administration compl\u00e8tre : bot/admin/web  pour l'administration NLP uniquement : nlp/admin/web   npm install\nng serve", 
            "title": "Lancer le projet  dans l'IDE"
        }, 
        {
            "location": "/contribuer/#code-conventions", 
            "text": "The format to follow is described in  Kotlin Code Conventions", 
            "title": "Code conventions"
        }
    ]
}